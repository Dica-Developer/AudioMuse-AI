<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Jellyfin Music Analyzer</title>
    <style>
        /* Dark Theme inspired by Jellyfin */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0; /* Remove default body margin */
            background-color: #2e2e3f; /* Dark background */
            color: #dcdcdc; /* Light text */
            line-height: 1.6;
            display: flex;
            justify-content: center;
            align-items: flex-start; /* Align items to the top */
            min-height: 100vh;
            padding: 20px 0; /* Add padding top/bottom */
        }
        .container {
            width: 100%;
            max-width: 1000px; /* Wider container */
            background: #3a3a4c; /* Slightly lighter dark background for containers */
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.4); /* More pronounced shadow */
            margin-bottom: 20px;
        }
        h1, h2 {
            color: #e0e0e0; /* Lighter headings */
            border-bottom: 2px solid #5a5a6a; /* Subtle border */
            padding-bottom: 10px;
            margin-top: 25px;
        }
        .section {
            margin-bottom: 30px;
            padding: 20px;
            background-color: #4a4a5c; /* Even lighter background for sections */
            border-radius: 6px;
            border: 1px solid #5a5a6a;
        }
        .form-group {
            margin-bottom: 15px;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #c0c0c0; /* Slightly darker light text */
        }
        input[type="text"],
        input[type="number"],
        input[type="password"], /* Added for API Key */
        select {
            width: calc(100% - 22px);
            padding: 10px;
            border: 1px solid #666; /* Darker border */
            border-radius: 4px;
            font-size: 16px;
            box-sizing: border-box;
            background-color: #5a5a6a; /* Darker input background */
            color: #dcdcdc; /* Light input text */
        }
        button {
            background-color: #4CAF50; /* Green (Jellyfin green) */
            color: white;
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-right: 10px;
        }
        button:hover {
            background-color: #409244; /* Darker green on hover */
            transform: translateY(-1px);
        }
        button:active {
            transform: translateY(0);
        }
        button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }
        button.cancel-button {
            background-color: #e74c3c; /* Red */
        }
        button.cancel-button:hover {
            background-color: #c0392b; /* Darker red on hover */
        }
        button.show-more-button {
            background-color: #5c6bc0; /* A different blue */
            padding: 8px 15px;
            font-size: 14px;
            margin-left: 10px; /* Space from count */
            margin-bottom: 5px; /* space from ul */
        }
        button.show-more-button:hover {
            background-color: #4c5a9d;
        }
        .status-box {
            background-color: #3d3d4e; /* Slightly different dark background */
            border: 1px solid #6a6a7a;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        .status-box p {
            margin: 5px 0;
            color: #b0b0b0;
        }
        .progress-bar-container {
            width: 100%;
            background-color: #666; /* Darker progress bar background */
            border-radius: 5px;
            margin-top: 10px;
            overflow: hidden; /* Ensure text inside doesn't overflow rounded corners */
        }
        .progress-bar {
            width: 0%;
            height: 25px;
            background-color: #6c5ce7; /* Purple accent (Jellyfin purple) */
            border-radius: 5px; /* Needs to match container for full effect */
            text-align: center;
            line-height: 25px;
            color: white;
            font-weight: bold;
            transition: width 0.5s ease-out; /* Smooth progress animation */
        }
        pre {
            background-color: #2a2a35; /* Even darker for code/logs */
            padding: 15px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #4a4a5c;
            color: #a0a0a0; /* Log text color */
        }
        .hidden {
            display: none;
        }
        .config-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        .config-table th, .config-table td {
            border: 1px solid #5a5a6a;
            padding: 8px;
            text-align: left;
        }
        .config-table th {
            background-color: #4a4a5c;
            color: #e0e0e0;
        }
        .playlists-list ul {
            list-style: none;
            padding: 0;
            margin-top: 5px; /* Adjust spacing */
        }
        .playlists-list > div { /* Individual playlist container */
            background-color: #3d3d4e;
            margin-bottom: 12px;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #5a5a6a;
        }
        .playlists-list h3 {
            color: #7ed6df; /* Light blue accent for playlist names */
            margin-top: 0;
            margin-bottom: 5px;
            display: inline-block; /* Allow text and button on same line */
        }
        .playlists-list .track-count {
            color: #b0b0b0;
            font-size: 0.9em;
            margin-left: 10px;
        }
        .playlists-list ul.song-list {
            list-style: disc; /* Use bullets for songs */
            padding-left: 25px; /* Indent song list */
            margin-top: 10px;
            color: #c0c0c0;
        }
        .playlists-list ul.song-list li {
            background-color: transparent; /* No background for individual songs */
            border: none; /* No border for individual songs */
            padding: 3px 0; /* Smaller padding for songs */
            margin-bottom: 2px;
            font-size: 0.95em;
        }
        .mood-tags {
            margin-top: 15px;
            padding: 10px;
            background-color: #4a4a5c;
            border-radius: 5px;
            border: 1px solid #5a5a6a;
        }
        .mood-tags strong {
            color: #e0e0e0;
        }
        .mood-tags span {
            display: inline-block;
            background-color: #6c5ce7; /* Purple accent */
            color: white;
            padding: 5px 10px;
            border-radius: 15px;
            margin: 5px;
            font-size: 0.9em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Jellyfin Music Analyzer & Playlist Generator</h1>

        <div class="section" id="analysis-section">
            <h2>Music Analysis</h2>
            <p>Configure parameters for music feature extraction and mood prediction.</p>
            <div class="form-group">
                <label for="jellyfinUrl">Jellyfin URL (e.g., http://localhost:8096):</label>
                <input type="text" id="jellyfinUrl" placeholder="http://your-jellyfin-server:8096">
            </div>
            <div class="form-group">
                <label for="jellyfinUserId">Jellyfin User ID:</label>
                <input type="text" id="jellyfinUserId" placeholder="Your Jellyfin User ID">
            </div>
            <div class="form-group">
                <label for="jellyfinApiKey">Jellyfin API Key (Token):</label>
                <input type="password" id="jellyfinApiKey" placeholder="Your Jellyfin API Key">
            </div>
            <div class="form-group">
                <label for="numRecentAlbums">Number of Recent Albums to Analyze:</label>
                <input type="number" id="numRecentAlbums" value="50" min="1">
            </div>
            <div class="form-group">
                <label for="topNMoods">Top N Moods to Extract per Track:</label>
                <input type="number" id="topNMoods" value="5" min="1">
            </div>
            <button id="startAnalysisBtn">Start Analysis</button>
            <button id="cancelAnalysisBtn" class="cancel-button hidden">Cancel Analysis</button>

            <div class="status-box hidden" id="analysisStatusBox">
                <p>Status: <span id="analysisOverallStatus">Idle</span></p>
                <p>Progress: <span id="analysisProgressText">0%</span></p>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="analysisProgressBar"></div>
                </div>
                <p id="analysisAlbumInfo"></p>
                <p>Log Details:</p>
                <pre id="analysisLog"></pre>
            </div>
        </div>

        <div class="section" id="clustering-section">
            <h2>Playlist Clustering</h2>
            <p>Define how tracks are grouped into mood-based playlists.</p>
            <div class="form-group">
                <label for="clusteringMethod">Clustering Method:</label>
                <select id="clusteringMethod">
                    <option value="kmeans">K-Means</option>
                    <option value="dbscan">DBSCAN</option>
                </select>
            </div>

            <div id="kmeansParams">
                <div class="form-group">
                    <label for="numClusters">Number of Clusters (K-Means):</label>
                    <input type="number" id="numClusters" value="10" min="1">
                </div>
            </div>

            <div id="dbscanParams" class="hidden">
                <div class="form-group">
                    <label for="dbscanEps">DBSCAN Epsilon (eps):</label>
                    <input type="number" id="dbscanEps" value="0.5" step="0.01" min="0.01">
                </div>
                <div class="form-group">
                    <label for="dbscanMinSamples">DBSCAN Min Samples:</label>
                    <input type="number" id="dbscanMinSamples" value="5" min="1">
                </div>
            </div>
            <div class="form-group">
                <label for="pcaComponents">PCA Components (0 to disable PCA):</label>
                <input type="number" id="pcaComponents" value="0" min="0">
                <small style="color: #b0b0b0;">Higher values capture more variance but increase dimensionality.</small>
            </div>
             <div class="form-group">
                <label for="clusteringRuns">Number of Clustering Runs:</label>
                <input type="number" id="clusteringRuns" value="5" min="1">
                <small style="color: #b0b0b0;">More runs can lead to better cluster configurations for K-Means.</small>
            </div>
            <button id="startClusteringBtn">Start Clustering</button>
            <button id="cancelClusteringBtn" class="cancel-button hidden">Cancel Clustering</button>

            <div class="status-box hidden" id="clusteringStatusBox">
                <p>Status: <span id="clusteringOverallStatus">Idle</span></p>
                <p>Progress: <span id="clusteringProgressText">0%</span></p>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="clusteringProgressBar"></div>
                </div>
                <p>Log Details:</p>
                <pre id="clusteringLog"></pre>
                <div class="mood-tags hidden" id="predominantMoods">
                    <strong>Unique Predominant Moods Found:</strong> <span id="moodTagsList"></span>
                </div>
            </div>
        </div>

        <div class="section" id="playlists-section">
            <h2>Generated Playlists</h2>
            <div id="playlistsList" class="playlists-list">
                <p>No playlists generated yet or loaded. Run clustering to create some!</p>
                </div>
        </div>
    </div>

    <script>
        const API_BASE_URL = window.location.origin;

        let analysisTaskId = null;
        let clusteringTaskId = null;
        let analysisInterval = null;
        let clusteringInterval = null;

        // Define a set of "final" states for a task
        const FINAL_TASK_STATES = ['SUCCESS', 'FAILURE', 'REVOKED'];

        document.addEventListener('DOMContentLoaded', () => {
            loadConfigAndDefaults();
            setupEventListeners();
            // Check last task status for both types on load
            checkLastTaskStatus('analysis');
            checkLastTaskStatus('clustering');
            loadPlaylists(); // Load playlists on initial page load
        });

        function setupEventListeners() {
            document.getElementById('startAnalysisBtn').addEventListener('click', startAnalysis);
            document.getElementById('cancelAnalysisBtn').addEventListener('click', () => cancelTask(analysisTaskId, 'analysis'));
            document.getElementById('startClusteringBtn').addEventListener('click', startClustering);
            document.getElementById('cancelClusteringBtn').addEventListener('click', () => cancelTask(clusteringTaskId, 'clustering'));
            document.getElementById('clusteringMethod').addEventListener('change', toggleClusteringParams);
        }

        async function loadConfigAndDefaults() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/config`);
                const config = await response.json();
                console.log('Loaded config:', config);

                // Set default values for analysis inputs
                document.getElementById('jellyfinUrl').value = config.jellyfin_url || '';
                document.getElementById('jellyfinUserId').value = config.jellyfin_user_id || '';
                // WARNING: Do NOT pre-fill API key for security reasons in production.
                // For a simple local app, we'll allow it, but best practice is to require re-entry.
                document.getElementById('jellyfinApiKey').value = config.jellyfin_token || '';

                document.getElementById('numRecentAlbums').value = config.num_recent_albums || 50;
                document.getElementById('topNMoods').value = config.top_n_moods || 5;

                // Set default values for clustering inputs
                document.getElementById('clusteringMethod').value = config.cluster_algorithm || 'kmeans';
                document.getElementById('numClusters').value = config.num_clusters || 10;
                document.getElementById('dbscanEps').value = config.dbscan_eps || 0.5;
                document.getElementById('dbscanMinSamples').value = config.dbscan_min_samples || 5;
                document.getElementById('pcaComponents').value = config.pca_enabled ? config.pca_components : 0;
                document.getElementById('clusteringRuns').value = config.clustering_runs || 5;

                toggleClusteringParams(); // Initialize correct params visibility based on loaded config
            } catch (error) {
                console.error('Error loading configuration:', error);
                // Optionally show a user-friendly message, but for development, console is fine.
                // alert('Failed to load configuration. Using hardcoded defaults. See console for details.');
            }
        }

        function toggleClusteringParams() {
            const method = document.getElementById('clusteringMethod').value;
            document.getElementById('kmeansParams').classList.toggle('hidden', method !== 'kmeans');
            document.getElementById('dbscanParams').classList.toggle('hidden', method !== 'dbscan');
        }

        async function startAnalysis() {
            const jellyfinUrl = document.getElementById('jellyfinUrl').value;
            const jellyfinUserId = document.getElementById('jellyfinUserId').value;
            const jellyfinApiKey = document.getElementById('jellyfinApiKey').value;
            const numRecentAlbums = document.getElementById('numRecentAlbums').value;
            const topNMoods = document.getElementById('topNMoods').value;

            if (!jellyfinUrl || !jellyfinUserId || !jellyfinApiKey) {
                alert('Please fill in all Jellyfin connection details.');
                return;
            }

            const startBtn = document.getElementById('startAnalysisBtn');
            const cancelBtn = document.getElementById('cancelAnalysisBtn');
            const statusBox = document.getElementById('analysisStatusBox');

            // Reset UI for new task
            statusBox.classList.remove('hidden');
            document.getElementById('analysisLog').textContent = '';
            document.getElementById('analysisOverallStatus').textContent = 'Starting...';
            document.getElementById('analysisProgressText').textContent = '0%';
            document.getElementById('analysisProgressBar').style.width = '0%';
            document.getElementById('analysisProgressBar').textContent = '0%';
            document.getElementById('analysisAlbumInfo').textContent = '';

            startBtn.disabled = true;
            cancelBtn.classList.remove('hidden');

            try {
                const response = await fetch(`${API_BASE_URL}/api/analysis/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jellyfin_url: jellyfinUrl,
                        jellyfin_user_id: jellyfinUserId,
                        jellyfin_token: jellyfinApiKey,
                        num_recent_albums: parseInt(numRecentAlbums),
                        top_n_moods: parseInt(topNMoods)
                    })
                });
                const data = await response.json();
                analysisTaskId = data.task_id;
                console.log('Analysis task started:', data);
                startPolling(analysisTaskId, 'analysis');
            } catch (error) {
                console.error('Error starting analysis:', error);
                alert('Failed to start analysis. See console for details.');
                resetButtons('analysis');
                statusBox.classList.add('hidden'); // Hide status box if start fails
            }
        }

        async function startClustering() {
            const clusteringMethod = document.getElementById('clusteringMethod').value;
            const numClusters = document.getElementById('numClusters').value;
            const dbscanEps = document.getElementById('dbscanEps').value;
            const dbscanMinSamples = document.getElementById('dbscanMinSamples').value;
            const pcaComponents = document.getElementById('pcaComponents').value;
            const clusteringRuns = document.getElementById('clusteringRuns').value;

            // Re-fetch Jellyfin credentials to pass to clustering task for playlist creation
            const jellyfinUrl = document.getElementById('jellyfinUrl').value;
            const jellyfinUserId = document.getElementById('jellyfinUserId').value;
            const jellyfinApiKey = document.getElementById('jellyfinApiKey').value;

            if (!jellyfinUrl || !jellyfinUserId || !jellyfinApiKey) {
                alert('Please fill in all Jellyfin connection details in the Analysis section first.');
                return;
            }

            const startBtn = document.getElementById('startClusteringBtn');
            const cancelBtn = document.getElementById('cancelClusteringBtn');
            const statusBox = document.getElementById('clusteringStatusBox');

            // Reset UI for new task
            statusBox.classList.remove('hidden');
            document.getElementById('clusteringLog').textContent = '';
            document.getElementById('clusteringOverallStatus').textContent = 'Starting...';
            document.getElementById('clusteringProgressText').textContent = '0%';
            document.getElementById('clusteringProgressBar').style.width = '0%';
            document.getElementById('clusteringProgressBar').textContent = '0%';
            document.getElementById('predominantMoods').classList.add('hidden');
            document.getElementById('moodTagsList').innerHTML = '';


            startBtn.disabled = true;
            cancelBtn.classList.remove('hidden');

            const payload = {
                jellyfin_url: jellyfinUrl,
                jellyfin_user_id: jellyfinUserId,
                jellyfin_token: jellyfinApiKey,
                clustering_method: clusteringMethod,
                num_clusters: parseInt(numClusters),
                dbscan_eps: parseFloat(dbscanEps),
                dbscan_min_samples: parseInt(dbscanMinSamples),
                pca_components: parseInt(pcaComponents),
                pca_enabled: parseInt(pcaComponents) > 0,
                clustering_runs: parseInt(clusteringRuns)
            };

            try {
                const response = await fetch(`${API_BASE_URL}/api/clustering/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                const data = await response.json();
                clusteringTaskId = data.task_id;
                console.log('Clustering task started:', data);
                startPolling(clusteringTaskId, 'clustering');
            } catch (error) {
                console.error('Error starting clustering:', error);
                alert('Failed to start clustering. See console for details.');
                resetButtons('clustering');
                statusBox.classList.add('hidden'); // Hide status box if start fails
            }
        }

        function updateTaskUI(type, data) {
            const overallStatusSpan = document.getElementById(`${type}OverallStatus`);
            const progressTextSpan = document.getElementById(`${type}ProgressText`);
            const progressBarDiv = document.getElementById(`${type}ProgressBar`);
            const logPre = document.getElementById(`${type}Log`);
            const albumInfoP = document.getElementById('analysisAlbumInfo');
            const predominantMoodsDiv = document.getElementById('predominantMoods');
            const moodTagsListSpan = document.getElementById('moodTagsList');

            overallStatusSpan.textContent = data.status || data.state;

            const progress = data.progress !== undefined ? data.progress : 0;
            progressTextSpan.textContent = `${progress}%`;
            progressBarDiv.style.width = `${progress}%`;
            progressBarDiv.textContent = `${progress}%`; // Display percentage inside bar

            if (type === 'analysis' && data.current_album) {
                albumInfoP.textContent = `Analyzing album: ${data.current_album} (${data.current_album_idx || 0}/${data.total_albums || 0})`;
            } else if (type === 'analysis') {
                 albumInfoP.textContent = ''; // Clear if no album info or on other tasks
            }

            if (data.log_output && Array.isArray(data.log_output)) {
                const newLogContent = data.log_output.join('\n');
                // Only update if content changed to avoid unnecessary re-renders
                if (logPre.textContent !== newLogContent) {
                    logPre.textContent = newLogContent;
                    logPre.scrollTop = logPre.scrollHeight; // Auto-scroll to bottom
                }
            } else {
                logPre.textContent = data.status || data.state;
            }

            // Handle predominant moods for clustering
            if (type === 'clustering') {
                if (data.state === 'SUCCESS' && data.unique_moods && data.unique_moods.length > 0) {
                    predominantMoodsDiv.classList.remove('hidden');
                    moodTagsListSpan.innerHTML = data.unique_moods.map(mood => `<span>${mood}</span>`).join('');
                } else if (data.state === 'SUCCESS' && data.unique_moods && data.unique_moods.length === 0) {
                     predominantMoodsDiv.classList.remove('hidden');
                     moodTagsListSpan.innerHTML = '<span>No distinct moods found for clustering.</span>';
                }
                else if (FINAL_TASK_STATES.includes(data.state) && data.state !== 'SUCCESS') {
                    predominantMoodsDiv.classList.add('hidden'); // Hide if failed/cancelled
                    moodTagsListSpan.innerHTML = '';
                }
            }
        }


        function startPolling(taskId, type) {
            const statusBox = document.getElementById(`${type}StatusBox`);
            statusBox.classList.remove('hidden');

            const poll = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/api/task/status/${taskId}`);
                    const data = await response.json();
                    // console.log(`${type} task status:`, data); // For debugging, can be noisy

                    updateTaskUI(type, data); // Update UI with current task data

                    if (FINAL_TASK_STATES.includes(data.state)) {
                        stopPolling(type);
                        resetButtons(type);
                        if (type === 'clustering' && data.state === 'SUCCESS') {
                            loadPlaylists(); // Load playlists after successful clustering
                        }
                    }
                } catch (error) {
                    console.error(`Error polling ${type} task status:`, error);
                    document.getElementById(`${type}OverallStatus`).textContent = `Error: ${error.message}`;
                    stopPolling(type);
                    resetButtons(type);
                }
            };

            stopPolling(type); // Clear any existing interval before starting a new one
            if (type === 'analysis') {
                analysisInterval = setInterval(poll, 1000);
            } else { // clustering
                clusteringInterval = setInterval(poll, 1000);
            }
            poll(); // Call immediately to get initial status
        }

        function stopPolling(type) {
            if (type === 'analysis' && analysisInterval) {
                clearInterval(analysisInterval);
                analysisInterval = null;
            } else if (type === 'clustering' && clusteringInterval) {
                clearInterval(clusteringInterval);
                clusteringInterval = null;
            }
        }

        function resetButtons(type) {
            if (type === 'analysis') {
                document.getElementById('startAnalysisBtn').disabled = false;
                document.getElementById('cancelAnalysisBtn').classList.add('hidden');
            } else { // clustering
                document.getElementById('startClusteringBtn').disabled = false;
                document.getElementById('cancelClusteringBtn').classList.add('hidden');
            }
        }

        async function cancelTask(taskId, type) {
            if (!taskId) {
                alert('No task running to cancel.');
                return;
            }
            if (!confirm(`Are you sure you want to cancel the ${type} task (ID: ${taskId})?`)) {
                return;
            }

            const overallStatusSpan = document.getElementById(`${type}OverallStatus`);
            const logPre = document.getElementById(`${type}Log`);

            overallStatusSpan.textContent = 'Cancelling...';
            logPre.textContent += '\nCancellation requested...'; // Add to log
            logPre.scrollTop = logPre.scrollHeight; // Auto-scroll to bottom

            try {
                const response = await fetch(`${API_BASE_URL}/api/task/cancel/${taskId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                const data = await response.json();
                console.log(`Cancellation response for ${type} task:`, data);

                // Immediately update UI based on the response from the backend
                // This ensures 'REVOKED' is shown quickly if the backend confirms it.
                // The 'data.task_type' from the backend response is used for consistency.
                updateTaskUI(type, {
                    task_id: taskId,
                    state: data.state, // Should be 'REVOKED' from backend
                    status: data.message, // Message from backend
                    progress: 100,
                    log_output: (logPre.textContent + '\n' + data.message).split('\n'), // Merge existing log
                    task_type: data.task_type // Use the task_type returned by the backend
                });
                stopPolling(type); // Ensure polling stops
                resetButtons(type); // Reset buttons

                if (type === 'clustering') {
                    // Hide predominant moods if clustering was cancelled
                    document.getElementById('predominantMoods').classList.add('hidden');
                    document.getElementById('moodTagsList').innerHTML = '';
                }

            } catch (error) {
                console.error(`Error requesting cancellation of ${type} task:`, error);
                alert(`Failed to send cancel request. See console for details: ${error.message}`);
                overallStatusSpan.textContent = `Error during cancellation: ${error.message}`;
                // Do not reset buttons or stop polling immediately if cancellation request itself failed
                // The polling loop will eventually time out or report failure if the task is truly stuck.
            }
        }

        async function checkLastTaskStatus(type) {
            try {
                const response = await fetch(`${API_BASE_URL}/api/${type}/last_task`);
                const data = await response.json();
                console.log(`Last ${type} task check result:`, data);

                const statusBox = document.getElementById(`${type}StatusBox`);

                if (data.task_id && data.status !== 'NO_PREVIOUS_TASK') {
                    // Update UI with the state of the last task
                    statusBox.classList.remove('hidden');
                    // Fetch full task info to get progress, logs, etc. for the last task
                    const fullTaskResponse = await fetch(`${API_BASE_URL}/api/task/status/${data.task_id}`);
                    const fullTaskData = await fullTaskResponse.json();
                    updateTaskUI(type, fullTaskData);

                    if (FINAL_TASK_STATES.includes(fullTaskData.state)) {
                        console.log(`Last ${type} task (ID: ${data.task_id}) is in a final state: ${fullTaskData.state}. Not resuming polling.`);
                        resetButtons(type);
                    } else {
                        // If it's still active (PENDING, STARTED, PROGRESS), resume polling
                        if (type === 'analysis') {
                            analysisTaskId = data.task_id;
                        } else { // clustering
                            clusteringTaskId = data.task_id;
                        }
                        console.log(`Last ${type} task (ID: ${data.task_id}) is active: ${fullTaskData.state}. Resuming polling.`);
                        startPolling(data.task_id, type);
                        // Enable cancel button and disable start button if task is pending/in progress
                        if (type === 'analysis') {
                             document.getElementById('startAnalysisBtn').disabled = true;
                             document.getElementById('cancelAnalysisBtn').classList.remove('hidden');
                        } else {
                             document.getElementById('startClusteringBtn').disabled = true;
                             document.getElementById('cancelClusteringBtn').classList.remove('hidden');
                        }
                    }
                } else {
                     console.log(`No previous ${type} task found or it's not relevant.`);
                     statusBox.classList.add('hidden'); // Hide if no relevant task
                     resetButtons(type); // Ensure buttons are reset if no active task
                }
            } catch (error) {
                console.error(`Error checking last ${type} task status:`, error);
                document.getElementById(`${type}StatusBox`).classList.add('hidden'); // Hide status box on error
                resetButtons(type); // Ensure buttons are reset on error
            }
        }

        async function loadPlaylists() {
            try {
                const response = await fetch(`${API_BASE_URL}/api/playlists`);
                const playlists = await response.json();
                const playlistsListDiv = document.getElementById('playlistsList');
                playlistsListDiv.innerHTML = ''; // Clear existing content

                if (Object.keys(playlists).length === 0) {
                    playlistsListDiv.innerHTML = '<p>No playlists generated yet or loaded. Run clustering to create some!</p>';
                    return;
                }

                for (const playlistName in playlists) {
                    const playlistDiv = document.createElement('div');
                    const numSongs = playlists[playlistName].length;

                    const h3 = document.createElement('h3');
                    h3.textContent = playlistName;
                    playlistDiv.appendChild(h3);

                    const trackCountSpan = document.createElement('span');
                    trackCountSpan.className = 'track-count';
                    trackCountSpan.textContent = `(${numSongs} songs)`;
                    playlistDiv.appendChild(trackCountSpan);

                    if (numSongs > 0) {
                        const showMoreBtn = document.createElement('button');
                        showMoreBtn.className = 'show-more-button';
                        showMoreBtn.textContent = 'Show Songs';
                        playlistDiv.appendChild(showMoreBtn);

                        const ul = document.createElement('ul');
                        ul.className = 'song-list hidden'; // Initially hidden
                        playlists[playlistName].forEach(track => {
                            const li = document.createElement('li');
                            li.textContent = `${track.title} by ${track.author}`;
                            ul.appendChild(li);
                        });
                        playlistDiv.appendChild(ul);

                        showMoreBtn.addEventListener('click', () => {
                            ul.classList.toggle('hidden');
                            showMoreBtn.textContent = ul.classList.contains('hidden') ? 'Show Songs' : 'Hide Songs';
                        });
                    }

                    playlistsListDiv.appendChild(playlistDiv);
                }
            } catch (error) {
                console.error('Error loading playlists:', error);
                playlistsListDiv.innerHTML = '<p style="color: red;">Failed to load playlists.</p>';
            }
        }

    </script>
</body>
</html>
