<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Analyzer & Playlist Generator</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        /* Custom styles for better readability and spacing */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            line-height: 1.6;
        }
        .container {
            max-width: 1000px;
        }
        .card {
            background-color: #2d3748; /* Darker card background */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        input[type="text"],
        input[type="number"],
        textarea,
        select { /* Added select */
            background-color: #4a5568;
            border: 1px solid #4a5568;
            color: #e2e8f0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.25rem;
            width: 100%;
        }
        button {
            background-color: #63b3ed; /* Blue button */
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.25rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out;
        }
        button:hover {
            background-color: #4299e1; /* Darker blue on hover */
        }
        button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
        }
        .log-output {
            background-color: #171923; /* Even darker for logs */
            color: #cbd5e0;
            font-family: monospace;
            white-space: pre-wrap; /* Preserve whitespace and break lines */
            max-height: 300px;
            overflow-y: auto;
            border-radius: 0.25rem;
            padding: 1rem;
        }
        .status-box {
            padding: 1rem;
            border-radius: 0.25rem;
            font-weight: bold;
        }
        .status-PENDING { background-color: #2a4365; } /* Blue-gray */
        .status-PROGRESS { background-color: #3182ce; } /* Blue */
        .status-SUCCESS { background-color: #38a169; } /* Green */
        .status-FAILURE { background-color: #e53e3e; } /* Red */
        .status-REVOKED { background-color: #dd6b20; } /* Orange */


        .playlist-list {
            list-style: none;
            padding-left: 0;
        }
        .playlist-list li {
            background-color: #4a5568;
            margin-bottom: 0.5rem;
            padding: 0.75rem;
            border-radius: 0.25rem;
            display: flex;
            flex-direction: column; /* Changed to column for better layout of tracks */
            align-items: flex-start;
        }
        .playlist-list li:last-child {
            margin-bottom: 0;
        }
        .playlist-list h3 {
            color: #63b3ed;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
        }
        .playlist-toggle {
            background: none;
            border: none;
            color: #63b3ed;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            margin-left: auto; /* Push to right */
        }
        .playlist-tracks {
            margin-top: 0.5rem;
            border-top: 1px solid #63b3ed;
            padding-top: 0.5rem;
            width: 100%;
        }
        .playlist-tracks p {
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body class="p-8">
    <div class="container mx-auto">
        <h1 class="text-4xl font-bold text-center mb-8 text-blue-300">Essentia Music Analyzer & Playlist Generator</h1>

        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-white">Start Music Analysis</h2>
            <form id="analysisForm" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="jellyfin_url" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin URL:</label>
                    <input type="text" id="jellyfin_url" name="jellyfin_url" placeholder="Enter Jellyfin URL" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="jellyfin_user_id" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin User ID:</label>
                    <input type="text" id="jellyfin_user_id" name="jellyfin_user_id" placeholder="Enter Jellyfin User ID" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="jellyfin_token" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin API Token:</label>
                    <input type="text" id="jellyfin_token" name="jellyfin_token" placeholder="Enter Jellyfin API Token" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="num_recent_albums" class="block text-gray-400 text-sm font-bold mb-2">Number of Recent Albums (0 for all):</label>
                    <input type="number" id="num_recent_albums" name="num_recent_albums" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="top_n_moods" class="block text-gray-400 text-sm font-bold mb-2">Top N Moods per Track:</label>
                    <input type="number" id="top_n_moods" name="top_n_moods" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>

                <div class="col-span-1 md:col-span-2 mt-4 text-center">
                    <button type="submit" id="startAnalysisBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        Start Analysis
                    </button>
                </div>
            </form>
        </div>

        <div id="progressContainer" class="card p-6 mb-8 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Analysis Status</h2>
            <p class="text-lg mb-2 text-gray-300">Task ID: <span id="taskIdDisplay" class="font-bold text-blue-400">N/A</span></p>
            <p class="text-lg mb-4 status-box" id="analysisStatus">Status: Idle</p>
            <div class="w-full bg-gray-600 rounded-full h-4 mb-4">
                <div id="progressBar" class="bg-blue-500 h-4 rounded-full" style="width: 0%"></div>
            </div>
            <p class="text-gray-400 text-sm mb-2">Current Album: <span id="currentAlbumName">N/A</span> (<span id="currentAlbumProgress">0/0</span>)</p>
            <h3 class="text-xl font-semibold mb-2 text-white">Analysis Log:</h3>
            <pre id="logOutput" class="log-output"></pre>
            <div class="mt-4 text-center">
                   <button id="cancelAnalysisBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                    Cancel Analysis
                </button>
            </div>
        </div>

        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-white">Generate Playlists</h2>
            <form id="playlistForm" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="clustering_method" class="block text-gray-400 text-sm font-bold mb-2">Clustering Method:</label>
                    <select id="clustering_method" name="clustering_method" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                        <option value="kmeans">KMeans</option>
                        <option value="dbscan">DBSCAN</option>
                    </select>
                </div>
                <div id="kmeans_options">
                    <label for="num_clusters" class="block text-gray-400 text-sm font-bold mb-2">Number of Clusters (KMeans, 0 for auto):</label>
                    <input type="number" id="num_clusters" name="num_clusters" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div id="dbscan_options" class="hidden">
                    <div>
                        <label for="dbscan_eps" class="block text-gray-400 text-sm font-bold mb-2">DBSCAN Epsilon (eps):</label>
                        <input type="number" step="0.01" id="dbscan_eps" name="dbscan_eps" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                    <div class="mt-2">
                        <label for="dbscan_min_samples" class="block text-gray-400 text-sm font-bold mb-2">DBSCAN Min Samples:</label>
                        <input type="number" id="dbscan_min_samples" name="dbscan_min_samples" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                </div>
                <div>
                    <label for="pca_components" class="block text-gray-400 text-sm font-bold mb-2">PCA Components (0 to disable):</label>
                    <input type="number" id="pca_components" name="pca_components" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>

                <div class="col-span-1 md:col-span-2 mt-4 text-center">
                    <button type="submit" id="generatePlaylistsBtn" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        Generate Playlists
                    </button>
                    <button type="button" id="fetchPlaylistsBtn" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline ml-4">
                        Fetch Saved Playlists
                    </button>
                </div>
            </form>
        </div>

        <div id="playlistsDisplay" class="card p-6 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Generated Playlists</h2>
            <ul id="playlistList" class="playlist-list">
                </ul>
        </div>
    </div>

    <script>
        // --- KEY CHANGE HERE ---
        // By using a relative path, the browser will automatically use the same host and port
        // from which it loaded this index.html file (which will be your K3S LoadBalancer IP:8000).
        const API_BASE_URL = '/api';

        const analysisForm = document.getElementById('analysisForm');
        const startAnalysisBtn = document.getElementById('startAnalysisBtn');
        const progressContainer = document.getElementById('progressContainer');
        const taskIdDisplay = document.getElementById('taskIdDisplay');
        const analysisStatus = document.getElementById('analysisStatus');
        const progressBar = document.getElementById('progressBar');
        const currentAlbumName = document.getElementById('currentAlbumName');
        const currentAlbumProgress = document.getElementById('currentAlbumProgress');
        const logOutput = document.getElementById('logOutput');
        const cancelAnalysisBtn = document.getElementById('cancelAnalysisBtn');

        const playlistForm = document.getElementById('playlistForm');
        const clusteringMethodSelect = document.getElementById('clustering_method');
        const kmeansOptions = document.getElementById('kmeans_options');
        const dbscanOptions = document.getElementById('dbscan_options');
        const playlistsDisplay = document.getElementById('playlistsDisplay');
        const playlistList = document.getElementById('playlistList');
        const fetchPlaylistsBtn = document.getElementById('fetchPlaylistsBtn');

        let pollingInterval = null;
        let currentTaskId = null; // Removed localStorage.getItem here, will fetch from DB first

        // --- Utility Functions ---

        function showProgressContainer(show = true) {
            progressContainer.classList.toggle('hidden', !show);
        }

        function setAnalysisStatus(statusText, stateClass) {
            analysisStatus.textContent = `Status: ${statusText}`;
            analysisStatus.className = 'text-lg mb-4 status-box'; // Reset classes
            if (stateClass) {
                analysisStatus.classList.add(`status-${stateClass}`); // Add state-specific class
            }
        }

        function updateProgress(data) {
            // Update status text and color
            setAnalysisStatus(data.status, data.state);

            // Update progress bar
            const percentage = data.progress || 0; // Use 'progress' from meta
            progressBar.style.width = `${percentage}%`;

            // Update album name and progress
            currentAlbumName.textContent = data.current_album || 'N/A';
            currentAlbumProgress.textContent = `${data.current_album_idx || 0}/${data.total_albums || 0}`;

            // Update log output
            if (Array.isArray(data.log_output)) {
                logOutput.textContent = data.log_output.join('\n');
            } else {
                logOutput.textContent = String(data.log_output || '');
            }
            logOutput.scrollTop = logOutput.scrollHeight; // Auto-scroll to bottom

            // Handle task completion/failure/revocation
            if (['SUCCESS', 'FAILURE', 'REVOKED'].includes(data.state)) {
                clearInterval(pollingInterval);
                pollingInterval = null;
                startAnalysisBtn.disabled = false; // Re-enable start button
                cancelAnalysisBtn.disabled = true; // Disable cancel button
                currentTaskId = null; // Clear the task ID
            } else {
                 startAnalysisBtn.disabled = true; // Keep disabled if in progress
                 cancelAnalysisBtn.disabled = false;
            }
        }

        async function pollStatus(taskId) {
            if (pollingInterval) {
                clearInterval(pollingInterval); // Clear any existing interval
            }
            showProgressContainer(true); // Ensure progress container is visible when polling starts
            pollingInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/analysis/status/${taskId}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    taskIdDisplay.textContent = data.task_id;
                    updateProgress(data);
                } catch (error) {
                    console.error("Error polling analysis status:", error);
                    setAnalysisStatus(`Error polling: ${error.message || error}`, 'FAILURE');
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                    currentTaskId = null;
                }
            }, 3000); // Poll every 3 seconds
        }

        async function populateConfig() {
            try {
                const response = await fetch(`${API_BASE_URL}/config`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const config = await response.json();

                document.getElementById('jellyfin_url').value = config.jellyfin_url || '';
                document.getElementById('jellyfin_user_id').value = config.jellyfin_user_id || '';
                document.getElementById('jellyfin_token').value = config.jellyfin_token || '';
                document.getElementById('num_recent_albums').value = config.num_recent_albums !== undefined ? config.num_recent_albums : 0;
                document.getElementById('top_n_moods').value = config.top_n_moods !== undefined ? config.top_n_moods : 5;

                document.getElementById('clustering_method').value = config.cluster_algorithm || 'kmeans';
                document.getElementById('num_clusters').value = config.num_clusters !== undefined ? config.num_clusters : 40;
                document.getElementById('dbscan_eps').value = config.dbscan_eps !== undefined ? config.dbscan_eps : 0.15;
                document.getElementById('dbscan_min_samples').value = config.dbscan_min_samples !== undefined ? config.dbscan_min_samples : 10;
                document.getElementById('pca_components').value = config.pca_enabled ? 3 : 0; // Set to 3 if enabled, 0 if disabled

                toggleClusteringOptions(); // Adjust visibility based on loaded config
            } catch (error) {
                console.error("Failed to fetch initial configuration:", error);
                alert("Could not load initial configuration. Please check the backend API.");
            }
        }

        function toggleClusteringOptions() {
            if (clusteringMethodSelect.value === 'kmeans') {
                kmeansOptions.classList.remove('hidden');
                dbscanOptions.classList.add('hidden');
            } else {
                kmeansOptions.classList.add('hidden');
                dbscanOptions.classList.remove('hidden');
            }
        }

        async function fetchLastAnalysisStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/analysis/last_task`);
                const data = await response.json();
                if (data.task_id && ['PENDING', 'PROGRESS', 'STARTED'].includes(data.status)) {
                    currentTaskId = data.task_id;
                    taskIdDisplay.textContent = currentTaskId;
                    showProgressContainer(true);
                    setAnalysisStatus(data.status, data.status); // Initial status from DB
                    pollStatus(currentTaskId); // Resume polling
                } else if (data.task_id) {
                    // If a task existed but finished, show its final status without polling
                    currentTaskId = data.task_id;
                    taskIdDisplay.textContent = currentTaskId;
                    showProgressContainer(true);
                    setAnalysisStatus(data.status, data.status);
                    progressBar.style.width = '100%';
                    logOutput.textContent = `Previous task (ID: ${currentTaskId}) finished with status: ${data.status}.`;
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                } else {
                    showProgressContainer(false); // No previous task, hide progress
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                }
            } catch (error) {
                console.error("Error fetching last analysis status:", error);
                showProgressContainer(false); // Hide in case of error
                startAnalysisBtn.disabled = false;
                cancelAnalysisBtn.disabled = true;
            }
        }

        // --- Event Listeners ---

        analysisForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            startAnalysisBtn.disabled = true;
            cancelAnalysisBtn.disabled = false;
            logOutput.textContent = ''; // Clear previous logs
            progressBar.style.width = '0%';
            currentAlbumName.textContent = 'N/A';
            currentAlbumProgress.textContent = '0/0';
            setAnalysisStatus('Initiating...', 'PENDING');
            showProgressContainer(true);

            const formData = new FormData(analysisForm);
            const data = Object.fromEntries(formData.entries());

            // Convert numbers to actual numbers
            data.num_recent_albums = parseInt(data.num_recent_albums, 10);
            data.top_n_moods = parseInt(data.top_n_moods, 10);


            try {
                const response = await fetch(`${API_BASE_URL}/analysis/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                currentTaskId = result.task_id;
                taskIdDisplay.textContent = currentTaskId;
                pollStatus(currentTaskId);
                alert("Analysis started successfully!");
            } catch (error) {
                console.error("Error starting analysis:", error);
                alert(`Failed to start analysis: ${error.message || error}`);
                setAnalysisStatus('Failed to start', 'FAILURE');
                startAnalysisBtn.disabled = false;
                cancelAnalysisBtn.disabled = true;
                showProgressContainer(false); // Hide if start failed
            }
        });

        cancelAnalysisBtn.addEventListener('click', async () => {
            if (!currentTaskId) {
                alert("No active analysis to cancel.");
                return;
            }
            if (!confirm(`Are you sure you want to cancel analysis task ${currentTaskId}?`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/analysis/cancel/${currentTaskId}`, {
                    method: 'POST'
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                alert(result.message);
                if (pollingInterval) {
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                }
                setAnalysisStatus('Cancelled', 'REVOKED');
                startAnalysisBtn.disabled = false;
                cancelAnalysisBtn.disabled = true;
                currentTaskId = null; // Clear task ID on successful cancel
            } catch (error) {
                console.error("Error cancelling analysis:", error);
                alert(`Failed to cancel analysis: ${error.message || error}`);
            }
        });


        playlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            generatePlaylistsBtn.disabled = true;
            fetchPlaylistsBtn.disabled = true;
            try {
                const formData = new FormData(playlistForm);
                const data = Object.fromEntries(formData.entries());

                // Convert numbers and booleans
                data.num_clusters = parseInt(data.num_clusters, 10);
                data.dbscan_eps = parseFloat(data.dbscan_eps);
                data.dbscan_min_samples = parseInt(data.dbscan_min_samples, 10);
                const pca_components = parseInt(data.pca_components, 10);
                data.pca_enabled = pca_components > 0; // Send boolean based on input
                // Remove PCA components if 0, as it's not used in the backend for disabled PCA
                if (!data.pca_enabled) {
                    delete data.pca_components;
                }

                const response = await fetch(`${API_BASE_URL}/clustering`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                alert(result.message);
                // After successful generation, fetch the updated playlists
                fetchPlaylists();
            } catch (error) {
                console.error("Error generating playlists:", error);
                alert(`Failed to generate playlists: ${error.message || error}`);
            } finally {
                generatePlaylistsBtn.disabled = false;
                fetchPlaylistsBtn.disabled = false;
            }
        });

        clusteringMethodSelect.addEventListener('change', toggleClusteringOptions);

        async function fetchPlaylists() {
            playlistsDisplay.classList.add('hidden');
            playlistList.innerHTML = ''; // Clear existing list
            try {
                const response = await fetch(`${API_BASE_URL}/playlists`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const playlists = await response.json();
                if (Object.keys(playlists).length === 0) {
                    playlistList.innerHTML = '<li class="text-center text-gray-400">No playlists found. Run analysis and generate playlists first.</li>';
                } else {
                    for (const playlistName in playlists) {
                        const li = document.createElement('li');
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'playlist-toggle';
                        toggleBtn.textContent = 'Show Tracks';
                        toggleBtn.onclick = function() {
                            const tracksDiv = this.nextElementSibling;
                            if (tracksDiv.classList.contains('hidden')) {
                                tracksDiv.classList.remove('hidden');
                                this.textContent = 'Hide Tracks';
                            } else {
                                tracksDiv.classList.add('hidden');
                                this.textContent = 'Show Tracks';
                            }
                        };

                        const h3 = document.createElement('h3');
                        h3.innerHTML = `${playlistName} (${playlists[playlistName].length} tracks) `;
                        h3.appendChild(toggleBtn);
                        li.appendChild(h3);

                        const tracksDiv = document.createElement('div');
                        tracksDiv.className = 'playlist-tracks hidden'; // Hidden by default
                        playlists[playlistName].forEach(track => {
                            const p = document.createElement('p');
                            p.textContent = `${track.title} by ${track.author}`;
                            tracksDiv.appendChild(p);
                        });
                        li.appendChild(tracksDiv);
                        playlistList.appendChild(li);
                    }
                }
                playlistsDisplay.classList.remove('hidden');
            } catch (error) {
                console.error("Error fetching playlists:", error);
                playlistList.innerHTML = `<li class="text-center text-red-400">Failed to load playlists: ${error.message}</li>`;
                playlistsDisplay.classList.remove('hidden');
            }
        }

        fetchPlaylistsBtn.addEventListener('click', fetchPlaylists);

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', async () => {
            await populateConfig();
            await fetchLastAnalysisStatus(); // Check for ongoing or last task
        });
    </script>
</body>
</html>
