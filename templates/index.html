<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Analyzer & Playlist Generator</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        /* Custom styles for better readability and spacing */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            line-height: 1.6;
        }
        .container {
            max-width: 1000px;
        }
        .card {
            background-color: #2d3748; /* Darker card background */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        input[type="text"],
        input[type="number"],
        textarea,
        select { /* Added select */
            background-color: #4a5568;
            border: 1px solid #4a5568;
            color: #e2e8f0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.25rem;
            width: 100%;
        }
        button {
            background-color: #63b3ed; /* Blue button */
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.25rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out;
        }
        button:hover {
            background-color: #4299e1; /* Darker blue on hover */
        }
        button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
        }
        .log-output {
            background-color: #171923; /* Even darker for logs */
            color: #cbd5e0;
            font-family: monospace;
            white-space: pre-wrap; /* Preserve whitespace and break lines */
            max-height: 300px;
            overflow-y: auto;
            border-radius: 0.25rem;
            padding: 1rem;
        }
        .status-box {
            padding: 1rem;
            border-radius: 0.25rem;
            font-weight: bold;
        }
        .status-PENDING { background-color: #2a4365; } /* Blue-gray */
        .status-PROGRESS { background-color: #3182ce; } /* Blue */
        .status-SUCCESS { background-color: #38a169; } /* Green */
        .status-FAILURE { background-color: #e53e3e; } /* Red */
        .status-REVOKED { background-color: #dd6b20; } /* Orange */


        .playlist-list {
            list-style: none;
            padding-left: 0;
        }
        .playlist-list li {
            background-color: #4a5568;
            margin-bottom: 0.5rem;
            padding: 0.75rem;
            border-radius: 0.25rem;
            display: flex;
            flex-direction: column; /* Changed to column for better layout of tracks */
            align-items: flex-start;
        }
        .playlist-list li:last-child {
            margin-bottom: 0;
        }
        .playlist-list h3 {
            color: #63b3ed;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
        }
        .playlist-toggle {
            background: none;
            border: none;
            color: #63b3ed;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            margin-left: auto; /* Push to right */
        }
        .playlist-tracks {
            margin-top: 0.5rem;
            border-top: 1px solid #63b3ed;
            padding-top: 0.5rem;
            width: 100%;
        }
        .playlist-tracks p {
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body class="p-8">
    <div class="container mx-auto">
        <h1 class="text-4xl font-bold text-center mb-8 text-blue-300">Essentia Music Analyzer & Playlist Generator</h1>

        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-white">Start Music Analysis</h2>
            <form id="analysisForm" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="jellyfin_url" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin URL:</label>
                    <input type="text" id="jellyfin_url" name="jellyfin_url" placeholder="Enter Jellyfin URL" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="jellyfin_user_id" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin User ID:</label>
                    <input type="text" id="jellyfin_user_id" name="jellyfin_user_id" placeholder="Enter Jellyfin User ID" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="jellyfin_token" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin API Token:</label>
                    <input type="text" id="jellyfin_token" name="jellyfin_token" placeholder="Enter Jellyfin API Token" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="num_recent_albums" class="block text-gray-400 text-sm font-bold mb-2">Number of Recent Albums (0 for all):</label>
                    <input type="number" id="num_recent_albums" name="num_recent_albums" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="top_n_moods" class="block text-gray-400 text-sm font-bold mb-2">Top N Moods per Track:</label>
                    <input type="number" id="top_n_moods" name="top_n_moods" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>

                <div class="col-span-1 md:col-span-2 mt-4 text-center">
                    <button type="submit" id="startAnalysisBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        Start Analysis
                    </button>
                </div>
            </form>
        </div>

        <div id="analysisProgressContainer" class="card p-6 mb-8 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Analysis Status</h2>
            <p class="text-lg mb-2 text-gray-300">Task ID: <span id="analysisTaskIdDisplay" class="font-bold text-blue-400">N/A</span></p>
            <p class="text-lg mb-4 status-box" id="analysisStatus">Status: Idle</p>
            <div class="w-full bg-gray-600 rounded-full h-4 mb-4">
                <div id="analysisProgressBar" class="bg-blue-500 h-4 rounded-full" style="width: 0%"></div>
            </div>
            <p class="text-gray-400 text-sm mb-2">Current Album: <span id="currentAlbumName">N/A</span> (<span id="currentAlbumProgress">0/0</span>)</p>
            <h3 class="text-xl font-semibold mb-2 text-white">Analysis Log:</h3>
            <pre id="analysisLogOutput" class="log-output"></pre>
            <div class="mt-4 text-center">
                   <button id="cancelAnalysisBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                    Cancel Analysis
                </button>
            </div>
        </div>

        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-white">Generate Playlists</h2>
            <form id="playlistForm" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="clustering_method" class="block text-gray-400 text-sm font-bold mb-2">Clustering Method:</label>
                    <select id="clustering_method" name="clustering_method" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                        <option value="kmeans">KMeans</option>
                        <option value="dbscan">DBSCAN</option>
                    </select>
                </div>
                <div id="kmeans_options">
                    <label for="num_clusters" class="block text-gray-400 text-sm font-bold mb-2">Number of Clusters (KMeans, 0 for auto):</label>
                    <input type="number" id="num_clusters" name="num_clusters" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div id="dbscan_options" class="hidden">
                    <div>
                        <label for="dbscan_eps" class="block text-gray-400 text-sm font-bold mb-2">DBSCAN Epsilon (eps):</label>
                        <input type="number" step="0.01" id="dbscan_eps" name="dbscan_eps" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                    <div class="mt-2">
                        <label for="dbscan_min_samples" class="block text-gray-400 text-sm font-bold mb-2">DBSCAN Min Samples:</label>
                        <input type="number" id="dbscan_min_samples" name="dbscan_min_samples" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                </div>
                <div>
                    <label for="pca_components" class="block text-gray-400 text-sm font-bold mb-2">PCA Components (0 to disable):</label>
                    <input type="number" id="pca_components" name="pca_components" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="clustering_runs" class="block text-gray-400 text-sm font-bold mb-2">Clustering Runs (for diversity):</label>
                    <input type="number" id="clustering_runs" name="clustering_runs" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>

                <div class="col-span-1 md:col-span-2 mt-4 text-center">
                    <button type="submit" id="generatePlaylistsBtn" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        Generate Playlists
                    </button>
                    <button type="button" id="fetchPlaylistsBtn" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline ml-4">
                        Fetch Saved Playlists
                    </button>
                </div>
            </form>
        </div>

        <div id="clusteringProgressContainer" class="card p-6 mb-8 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Clustering Status</h2>
            <p class="text-lg mb-2 text-gray-300">Task ID: <span id="clusteringTaskIdDisplay" class="font-bold text-blue-400">N/A</span></p>
            <p class="text-lg mb-4 status-box" id="clusteringStatus">Status: Idle</p>
            <div class="w-full bg-gray-600 rounded-full h-4 mb-4">
                <div id="clusteringProgressBar" class="bg-blue-500 h-4 rounded-full" style="width: 0%"></div>
            </div>
            <p class="text-gray-400 text-sm mb-2">Current Step: <span id="currentClusteringStep">N/A</span> (<span id="currentClusteringProgress">0/0</span>)</p>
            <h3 class="text-xl font-semibold mb-2 text-white">Clustering Log:</h3>
            <pre id="clusteringLogOutput" class="log-output"></pre>
            <div class="mt-4 text-center">
                   <button id="cancelClusteringBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                    Cancel Clustering
                </button>
            </div>
        </div>
        <div id="playlistsDisplay" class="card p-6 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Generated Playlists</h2>
            <ul id="playlistList" class="playlist-list">
                </ul>
        </div>
    </div>

    <script>
        const API_BASE_URL = '/api';

        // Analysis Elements
        const analysisForm = document.getElementById('analysisForm');
        const startAnalysisBtn = document.getElementById('startAnalysisBtn');
        const analysisProgressContainer = document.getElementById('analysisProgressContainer');
        const analysisTaskIdDisplay = document.getElementById('analysisTaskIdDisplay');
        const analysisStatus = document.getElementById('analysisStatus');
        const analysisProgressBar = document.getElementById('analysisProgressBar');
        const currentAlbumName = document.getElementById('currentAlbumName');
        const currentAlbumProgress = document.getElementById('currentAlbumProgress');
        const analysisLogOutput = document.getElementById('analysisLogOutput');
        const cancelAnalysisBtn = document.getElementById('cancelAnalysisBtn');

        // Playlist/Clustering Elements
        const playlistForm = document.getElementById('playlistForm');
        const clusteringMethodSelect = document.getElementById('clustering_method');
        const kmeansOptions = document.getElementById('kmeans_options');
        const dbscanOptions = document.getElementById('dbscan_options');
        const generatePlaylistsBtn = document.getElementById('generatePlaylistsBtn');
        const fetchPlaylistsBtn = document.getElementById('fetchPlaylistsBtn');

        // NEW Clustering Progress Elements
        const clusteringProgressContainer = document.getElementById('clusteringProgressContainer');
        const clusteringTaskIdDisplay = document.getElementById('clusteringTaskIdDisplay');
        const clusteringStatus = document.getElementById('clusteringStatus');
        const clusteringProgressBar = document.getElementById('clusteringProgressBar');
        const currentClusteringStep = document.getElementById('currentClusteringStep');
        const currentClusteringProgress = document.getElementById('currentClusteringProgress');
        const clusteringLogOutput = document.getElementById('clusteringLogOutput');
        const cancelClusteringBtn = document.getElementById('cancelClusteringBtn');


        const clusteringRunsInput = document.getElementById('clustering_runs'); // Existing, just re-referencing

        const playlistsDisplay = document.getElementById('playlistsDisplay');
        const playlistList = document.getElementById('playlistList');

        let analysisPollingInterval = null;
        let currentAnalysisTaskId = null;

        let clusteringPollingInterval = null; // NEW
        let currentClusteringTaskId = null;   // NEW

        // --- Utility Functions ---

        function showProgressContainer(containerId, show = true) {
            document.getElementById(containerId).classList.toggle('hidden', !show);
        }

        function setStatus(statusElement, statusText, stateClass) {
            statusElement.textContent = `Status: ${statusText}`;
            statusElement.className = 'text-lg mb-4 status-box'; // Reset classes
            if (stateClass) {
                statusElement.classList.add(`status-${stateClass}`); // Add state-specific class
            }
        }

        // Renamed for clarity: updateAnalysisProgress and updateClusteringProgress
        function updateAnalysisProgress(data) {
            setStatus(analysisStatus, data.status, data.state);
            const percentage = data.progress || 0;
            analysisProgressBar.style.width = `${percentage}%`;
            currentAlbumName.textContent = data.current_album || 'N/A';
            currentAlbumProgress.textContent = `${data.current_album_idx || 0}/${data.total_albums || 0}`;
            if (Array.isArray(data.log_output)) {
                analysisLogOutput.textContent = data.log_output.join('\n');
            } else {
                analysisLogOutput.textContent = String(data.log_output || '');
            }
            analysisLogOutput.scrollTop = analysisLogOutput.scrollHeight;

            if (['SUCCESS', 'FAILURE', 'REVOKED'].includes(data.state)) {
                clearInterval(analysisPollingInterval);
                analysisPollingInterval = null;
                startAnalysisBtn.disabled = false;
                cancelAnalysisBtn.disabled = true;
                currentAnalysisTaskId = null;
            } else {
                startAnalysisBtn.disabled = true;
                cancelAnalysisBtn.disabled = false;
            }
        }

        // NEW: Function to update clustering progress UI
        function updateClusteringProgress(data) {
            setStatus(clusteringStatus, data.status, data.state);
            const percentage = data.progress || 0;
            clusteringProgressBar.style.width = `${percentage}%`;
            currentClusteringStep.textContent = data.current_step || 'N/A';
            currentClusteringProgress.textContent = `${data.current_step_idx || 0}/${data.total_steps || 0}`;
            if (Array.isArray(data.log_output)) {
                clusteringLogOutput.textContent = data.log_output.join('\n');
            } else {
                clusteringLogOutput.textContent = String(data.log_output || '');
            }
            clusteringLogOutput.scrollTop = clusteringLogOutput.scrollHeight;

            if (['SUCCESS', 'FAILURE', 'REVOKED'].includes(data.state)) {
                clearInterval(clusteringPollingInterval);
                clusteringPollingInterval = null;
                generatePlaylistsBtn.disabled = false; // Re-enable generate button
                cancelClusteringBtn.disabled = true;
                currentClusteringTaskId = null;
                // If clustering was successful, automatically fetch playlists
                if (data.state === 'SUCCESS') {
                    fetchPlaylists();
                }
            } else {
                generatePlaylistsBtn.disabled = true; // Keep disabled if in progress
                cancelClusteringBtn.disabled = false;
            }
            // Always enable fetch playlists if no clustering task is active (or if finished)
            fetchPlaylistsBtn.disabled = (currentClusteringTaskId !== null && data.state !== 'SUCCESS' && data.state !== 'FAILURE' && data.state !== 'REVOKED');
        }


        async function pollStatus(taskType, taskId, updateFn, taskIdDisplayElement, progressContainerId) {
            if (taskType === 'analysis' && analysisPollingInterval) {
                clearInterval(analysisPollingInterval);
            } else if (taskType === 'clustering' && clusteringPollingInterval) { // NEW
                clearInterval(clusteringPollingInterval);
            }

            showProgressContainer(progressContainerId, true);
            const intervalFn = async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/${taskType}/status/${taskId}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();
                    taskIdDisplayElement.textContent = data.task_id;
                    updateFn(data);
                } catch (error) {
                    console.error(`Error polling ${taskType} status:`, error);
                    updateFn({ // Create a generic error state
                        task_id: taskId,
                        state: 'FAILURE',
                        status: `Error polling: ${error.message || error}`,
                        progress: 0,
                        current_album: 'Error', // Re-use for analysis
                        current_step: 'Error', // Re-use for clustering
                        log_output: [`Error polling: ${error.message || error}`]
                    });
                    if (taskType === 'analysis') {
                        clearInterval(analysisPollingInterval);
                        analysisPollingInterval = null;
                        startAnalysisBtn.disabled = false;
                        cancelAnalysisBtn.disabled = true;
                        currentAnalysisTaskId = null;
                    } else if (taskType === 'clustering') { // NEW
                        clearInterval(clusteringPollingInterval);
                        clusteringPollingInterval = null;
                        generatePlaylistsBtn.disabled = false;
                        cancelClusteringBtn.disabled = true;
                        currentClusteringTaskId = null;
                    }
                }
            };

            if (taskType === 'analysis') {
                analysisPollingInterval = setInterval(intervalFn, 3000);
            } else if (taskType === 'clustering') { // NEW
                clusteringPollingInterval = setInterval(intervalFn, 3000);
            }
            intervalFn(); // Run immediately on start
        }

        async function populateConfig() {
            try {
                const response = await fetch(`${API_BASE_URL}/config`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const config = await response.json();

                document.getElementById('jellyfin_url').value = config.jellyfin_url || '';
                document.getElementById('jellyfin_user_id').value = config.jellyfin_user_id || '';
                document.getElementById('jellyfin_token').value = config.jellyfin_token || '';
                document.getElementById('num_recent_albums').value = config.num_recent_albums !== undefined ? config.num_recent_albums : 0;
                document.getElementById('top_n_moods').value = config.top_n_moods !== undefined ? config.top_n_moods : 5;

                document.getElementById('clustering_method').value = config.cluster_algorithm || 'kmeans';
                document.getElementById('num_clusters').value = config.num_clusters !== undefined ? config.num_clusters : 40;
                document.getElementById('dbscan_eps').value = config.dbscan_eps !== undefined ? config.dbscan_eps : 0.15;
                document.getElementById('dbscan_min_samples').value = config.dbscan_min_samples !== undefined ? config.dbscan_min_samples : 10;
                document.getElementById('pca_components').value = config.pca_enabled ? config.pca_components : 0; // Use config.pca_components
                clusteringRunsInput.value = config.clustering_runs !== undefined ? config.clustering_runs : 10;

                toggleClusteringOptions();
            } catch (error) {
                console.error("Failed to fetch initial configuration:", error);
                alert("Could not load initial configuration. Please check the backend API.");
            }
        }

        function toggleClusteringOptions() {
            if (clusteringMethodSelect.value === 'kmeans') {
                kmeansOptions.classList.remove('hidden');
                dbscanOptions.classList.add('hidden');
            } else {
                kmeansOptions.classList.add('hidden');
                dbscanOptions.classList.remove('hidden');
            }
        }

        // Modified to check for both analysis and clustering tasks
        async function fetchLastTaskStatuses() {
            try {
                // Fetch last analysis task status
                const analysisResponse = await fetch(`${API_BASE_URL}/analysis/last_task`);
                const analysisData = await analysisResponse.json();
                if (analysisData.task_id && ['PENDING', 'PROGRESS', 'STARTED'].includes(analysisData.status)) {
                    currentAnalysisTaskId = analysisData.task_id;
                    analysisTaskIdDisplay.textContent = currentAnalysisTaskId;
                    showProgressContainer('analysisProgressContainer', true);
                    setStatus(analysisStatus, analysisData.status, analysisData.status);
                    pollStatus('analysis', currentAnalysisTaskId, updateAnalysisProgress, analysisTaskIdDisplay, 'analysisProgressContainer');
                } else if (analysisData.task_id) {
                    currentAnalysisTaskId = analysisData.task_id;
                    analysisTaskIdDisplay.textContent = currentAnalysisTaskId;
                    showProgressContainer('analysisProgressContainer', true);
                    setStatus(analysisStatus, analysisData.status, analysisData.status);
                    analysisProgressBar.style.width = '100%';
                    analysisLogOutput.textContent = `Previous analysis task (ID: ${currentAnalysisTaskId}) finished with status: ${analysisData.status}.`;
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                } else {
                    showProgressContainer('analysisProgressContainer', false);
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                }

                // NEW: Fetch last clustering task status
                const clusteringResponse = await fetch(`${API_BASE_URL}/clustering/last_task`);
                const clusteringData = await clusteringResponse.json();
                if (clusteringData.task_id && ['PENDING', 'PROGRESS', 'STARTED'].includes(clusteringData.status)) {
                    currentClusteringTaskId = clusteringData.task_id;
                    clusteringTaskIdDisplay.textContent = currentClusteringTaskId;
                    showProgressContainer('clusteringProgressContainer', true);
                    setStatus(clusteringStatus, clusteringData.status, clusteringData.status);
                    pollStatus('clustering', currentClusteringTaskId, updateClusteringProgress, clusteringTaskIdDisplay, 'clusteringProgressContainer');
                } else if (clusteringData.task_id) {
                    currentClusteringTaskId = clusteringData.task_id;
                    clusteringTaskIdDisplay.textContent = currentClusteringTaskId;
                    showProgressContainer('clusteringProgressContainer', true);
                    setStatus(clusteringStatus, clusteringData.status, clusteringData.status);
                    clusteringProgressBar.style.width = '100%';
                    clusteringLogOutput.textContent = `Previous clustering task (ID: ${currentClusteringTaskId}) finished with status: ${clusteringData.status}.`;
                    generatePlaylistsBtn.disabled = false;
                    cancelClusteringBtn.disabled = true;
                    // If the last clustering task was successful, fetch playlists
                    if (clusteringData.status === 'SUCCESS') {
                        fetchPlaylists();
                    }
                } else {
                    showProgressContainer('clusteringProgressContainer', false);
                    generatePlaylistsBtn.disabled = false;
                    cancelClusteringBtn.disabled = true;
                }
            } catch (error) {
                console.error("Error fetching last task statuses:", error);
                showProgressContainer('analysisProgressContainer', false);
                showProgressContainer('clusteringProgressContainer', false);
                startAnalysisBtn.disabled = false;
                cancelAnalysisBtn.disabled = true;
                generatePlaylistsBtn.disabled = false;
                cancelClusteringBtn.disabled = true;
            } finally {
                 // Ensure fetch playlists button is enabled if no clustering task is active (or if finished)
                if (!currentClusteringTaskId) {
                    fetchPlaylistsBtn.disabled = false;
                }
            }
        }

        // --- Event Listeners ---

        analysisForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            startAnalysisBtn.disabled = true;
            cancelAnalysisBtn.disabled = false;
            analysisLogOutput.textContent = '';
            analysisProgressBar.style.width = '0%';
            currentAlbumName.textContent = 'N/A';
            currentAlbumProgress.textContent = '0/0';
            setStatus(analysisStatus, 'Initiating...', 'PENDING');
            showProgressContainer('analysisProgressContainer', true);

            const formData = new FormData(analysisForm);
            const data = Object.fromEntries(formData.entries());
            data.num_recent_albums = parseInt(data.num_recent_albums, 10);
            data.top_n_moods = parseInt(data.top_n_moods, 10);

            try {
                const response = await fetch(`${API_BASE_URL}/analysis/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                currentAnalysisTaskId = result.task_id;
                analysisTaskIdDisplay.textContent = currentAnalysisTaskId;
                pollStatus('analysis', currentAnalysisTaskId, updateAnalysisProgress, analysisTaskIdDisplay, 'analysisProgressContainer');
                alert("Analysis started successfully!");
            } catch (error) {
                console.error("Error starting analysis:", error);
                alert(`Failed to start analysis: ${error.message || error}`);
                setStatus(analysisStatus, 'Failed to start', 'FAILURE');
                startAnalysisBtn.disabled = false;
                cancelAnalysisBtn.disabled = true;
                showProgressContainer('analysisProgressContainer', false);
            }
        });

        cancelAnalysisBtn.addEventListener('click', async () => {
            if (!currentAnalysisTaskId) {
                alert("No active analysis to cancel.");
                return;
            }
            if (!confirm(`Are you sure you want to cancel analysis task ${currentAnalysisTaskId}?`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/analysis/cancel/${currentAnalysisTaskId}`, {
                    method: 'POST'
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                alert(result.message);
                if (analysisPollingInterval) {
                    clearInterval(analysisPollingInterval);
                    analysisPollingInterval = null;
                }
                setStatus(analysisStatus, 'Cancelled', 'REVOKED');
                startAnalysisBtn.disabled = false;
                cancelAnalysisBtn.disabled = true;
                currentAnalysisTaskId = null;
            } catch (error) {
                console.error("Error cancelling analysis:", error);
                alert(`Failed to cancel analysis: ${error.message || error}`);
            }
        });


        playlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            generatePlaylistsBtn.disabled = true;
            fetchPlaylistsBtn.disabled = true; // Disable fetch while new clustering starts
            cancelClusteringBtn.disabled = false;
            clusteringLogOutput.textContent = '';
            clusteringProgressBar.style.width = '0%';
            currentClusteringStep.textContent = 'N/A';
            currentClusteringProgress.textContent = '0/0';
            setStatus(clusteringStatus, 'Initiating...', 'PENDING');
            showProgressContainer('clusteringProgressContainer', true); // Show new container

            try {
                const formData = new FormData(playlistForm);
                const data = Object.fromEntries(formData.entries());

                data.num_clusters = parseInt(data.num_clusters, 10);
                data.dbscan_eps = parseFloat(data.dbscan_eps);
                data.dbscan_min_samples = parseInt(data.dbscan_min_samples, 10);
                const pca_components = parseInt(data.pca_components, 10);
                data.pca_enabled = pca_components > 0;
                if (!data.pca_enabled) {
                    delete data.pca_components;
                }
                data.clustering_runs = parseInt(data.clustering_runs, 10);

                // NEW: Call the new clustering endpoint
                const response = await fetch(`${API_BASE_URL}/clustering`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                currentClusteringTaskId = result.task_id; // Store clustering task ID
                clusteringTaskIdDisplay.textContent = currentClusteringTaskId;
                // NEW: Start polling for clustering status
                pollStatus('clustering', currentClusteringTaskId, updateClusteringProgress, clusteringTaskIdDisplay, 'clusteringProgressContainer');
                alert("Clustering started successfully!");
            } catch (error) {
                console.error("Error generating playlists:", error);
                alert(`Failed to generate playlists: ${error.message || error}`);
                setStatus(clusteringStatus, 'Failed to start', 'FAILURE');
                generatePlaylistsBtn.disabled = false;
                fetchPlaylistsBtn.disabled = false;
                cancelClusteringBtn.disabled = true;
                showProgressContainer('clusteringProgressContainer', false);
            }
        });

        // NEW: Event listener for canceling clustering
        cancelClusteringBtn.addEventListener('click', async () => {
            if (!currentClusteringTaskId) {
                alert("No active clustering to cancel.");
                return;
            }
            if (!confirm(`Are you sure you want to cancel clustering task ${currentClusteringTaskId}?`)) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE_URL}/clustering/cancel/${currentClusteringTaskId}`, {
                    method: 'POST'
                });
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                alert(result.message);
                if (clusteringPollingInterval) {
                    clearInterval(clusteringPollingInterval);
                    clusteringPollingInterval = null;
                }
                setStatus(clusteringStatus, 'Cancelled', 'REVOKED');
                generatePlaylistsBtn.disabled = false;
                cancelClusteringBtn.disabled = true;
                fetchPlaylistsBtn.disabled = false; // Enable fetch playlists after cancel
                currentClusteringTaskId = null;
            } catch (error) {
                console.error("Error cancelling clustering:", error);
                alert(`Failed to cancel clustering: ${error.message || error}`);
            }
        });


        clusteringMethodSelect.addEventListener('change', toggleClusteringOptions);

        async function fetchPlaylists() {
            // Only fetch playlists if no clustering task is currently active
            if (currentClusteringTaskId && ['PENDING', 'PROGRESS', 'STARTED'].includes(clusteringStatus.dataset.status)) {
                alert("Clustering is in progress. Please wait for it to complete or cancel it before fetching playlists.");
                return;
            }

            playlistsDisplay.classList.add('hidden');
            playlistList.innerHTML = ''; // Clear existing list
            try {
                const response = await fetch(`${API_BASE_URL}/playlists`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const playlists = await response.json();
                if (Object.keys(playlists).length === 0) {
                    playlistList.innerHTML = '<li class="text-center text-gray-400">No playlists found. Run analysis and generate playlists first.</li>';
                } else {
                    for (const playlistName in playlists) {
                        const li = document.createElement('li');
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'playlist-toggle';
                        toggleBtn.textContent = 'Show Tracks';
                        toggleBtn.onclick = function() {
                            const tracksDiv = this.nextElementSibling;
                            if (tracksDiv.classList.contains('hidden')) {
                                tracksDiv.classList.remove('hidden');
                                this.textContent = 'Hide Tracks';
                            } else {
                                tracksDiv.classList.add('hidden');
                                this.textContent = 'Show Tracks';
                            }
                        };

                        const h3 = document.createElement('h3');
                        h3.innerHTML = `${playlistName} (${playlists[playlistName].length} tracks) `;
                        h3.appendChild(toggleBtn);
                        li.appendChild(h3);

                        const tracksDiv = document.createElement('div');
                        tracksDiv.className = 'playlist-tracks hidden'; // Hidden by default
                        playlists[playlistName].forEach(track => {
                            const p = document.createElement('p');
                            p.textContent = `${track.title} by ${track.author}`;
                            tracksDiv.appendChild(p);
                        });
                        li.appendChild(tracksDiv);
                        playlistList.appendChild(li);
                    }
                }
                playlistsDisplay.classList.remove('hidden');
            } catch (error) {
                console.error("Error fetching playlists:", error);
                playlistList.innerHTML = `<li class="text-center text-red-400">Failed to load playlists: ${error.message}</li>`;
                playlistsDisplay.classList.remove('hidden');
            }
        }

        fetchPlaylistsBtn.addEventListener('click', fetchPlaylists);

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', async () => {
            await populateConfig();
            await fetchLastTaskStatuses(); // Check for ongoing or last tasks for both
        });
    </script>
</body>
</html>
