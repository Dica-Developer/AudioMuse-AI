<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Analyzer & Playlist Generator</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/tailwindcss/2.2.19/tailwind.min.css" rel="stylesheet">
    <style>
        /* Custom styles for better readability and spacing */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            line-height: 1.6;
        }
        .container {
            max-width: 1000px;
        }
        .card {
            background-color: #2d3748; /* Darker card background */
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        input[type="text"],
        input[type="number"],
        textarea,
        select { /* Added select */
            background-color: #4a5568;
            border: 1px solid #4a5568;
            color: #e2e8f0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.25rem;
            width: 100%;
        }
        button {
            background-color: #63b3ed; /* Blue button */
            color: #ffffff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.25rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out;
        }
        button:hover {
            background-color: #4299e1; /* Darker blue on hover */
        }
        button:disabled {
            background-color: #a0aec0;
            cursor: not-allowed;
        }
        .log-output {
            background-color: #171923; /* Even darker for logs */
            color: #cbd5e0;
            font-family: monospace;
            white-space: pre-wrap; /* Preserve whitespace and break lines */
            max-height: 300px;
            overflow-y: auto;
            border-radius: 0.25rem;
            padding: 1rem;
        }
        .status-box {
            padding: 1rem;
            border-radius: 0.25rem;
            font-weight: bold;
        }
        .status-PENDING { background-color: #2a4365; } /* Blue-gray */
        .status-PROGRESS { background-color: #3182ce; } /* Blue */
        .status-SUCCESS { background-color: #38a169; } /* Green */
        .status-FAILURE { background-color: #e53e3e; } /* Red */
        .status-REVOKED { background-color: #dd6b20; } /* Orange */


        .playlist-list {
            list-style: none;
            padding-left: 0;
        }
        .playlist-list li {
            background-color: #4a5568;
            margin-bottom: 0.5rem;
            padding: 0.75rem;
            border-radius: 0.25rem;
            display: flex;
            flex-direction: column; /* Changed to column for better layout of tracks */
            align-items: flex-start;
        }
        .playlist-list li:last-child {
            margin-bottom: 0;
        }
        .playlist-list h3 {
            color: #63b3ed;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            width: 100%;
            align-items: center;
        }
        .playlist-toggle {
            background: none;
            border: none;
            color: #63b3ed;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            margin-left: auto; /* Push to right */
        }
        .playlist-tracks {
            margin-top: 0.5rem;
            border-top: 1px solid #63b3ed;
            padding-top: 0.5rem;
            width: 100%;
        }
        .playlist-tracks p {
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body class="p-8">
    <div class="container mx-auto">
        <h1 class="text-4xl font-bold text-center mb-8 text-blue-300">AudioMuse-AI - Music Analyzer & Playlist Generator</h1>

        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-white">Start Music Analysis</h2>
            <form id="analysisForm" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="jellyfin_url" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin URL:</label>
                    <input type="text" id="jellyfin_url" name="jellyfin_url" placeholder="Enter Jellyfin URL" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="jellyfin_user_id" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin User ID:</label>
                    <input type="text" id="jellyfin_user_id" name="jellyfin_user_id" placeholder="Enter Jellyfin User ID" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="jellyfin_token" class="block text-gray-400 text-sm font-bold mb-2">Jellyfin API Token:</label>
                    <input type="text" id="jellyfin_token" name="jellyfin_token" placeholder="Enter Jellyfin API Token" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="num_recent_albums" class="block text-gray-400 text-sm font-bold mb-2">Number of Recent Albums (0 for all):</label>
                    <input type="number" id="num_recent_albums" name="num_recent_albums" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="top_n_moods" class="block text-gray-400 text-sm font-bold mb-2">Top N Moods per Track:</label>
                    <input type="number" id="top_n_moods" name="top_n_moods" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>

                <div class="col-span-1 md:col-span-2 mt-4 text-center">
                    <button type="submit" id="startAnalysisBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        Start Analysis
                    </button>
                </div>
            </form>
        </div>

        <div id="analysisProgressContainer" class="card p-6 mb-8 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Analysis Status</h2>
            <p class="text-lg mb-2 text-gray-300">Task ID: <span id="analysisTaskIdDisplay" class="font-bold text-blue-400">N/A</span></p>
            <p class="text-lg mb-4 status-box" id="analysisStatus">Status: Idle</p>
            <div class="w-full bg-gray-600 rounded-full h-4 mb-4">
                <div id="analysisProgressBar" class="bg-blue-500 h-4 rounded-full" style="width: 0%"></div>
            </div>
            <p class="text-gray-400 text-sm mb-2">Current Album: <span id="currentAlbumName">N/A</span> (<span id="currentAlbumProgress">0/0</span>)</p>
            <h3 class="text-xl font-semibold mb-2 text-white">Analysis Log:</h3>
            <pre id="analysisLogOutput" class="log-output"></pre>
            <div class="mt-4 text-center">
                   <button id="cancelAnalysisBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                    Cancel Analysis
                </button>
            </div>
        </div>

        <div class="card p-6 mb-8">
            <h2 class="text-2xl font-semibold mb-4 text-white">Generate Playlists</h2>
            <form id="playlistForm" class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="clustering_method" class="block text-gray-400 text-sm font-bold mb-2">Clustering Method:</label>
                    <select id="clustering_method" name="clustering_method" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                        <option value="kmeans">KMeans</option>
                        <option value="dbscan">DBSCAN</option>
                    </select>
                </div>
                <div id="kmeans_options">
                    <label for="num_clusters" class="block text-gray-400 text-sm font-bold mb-2">Number of Clusters (KMeans, 0 for auto):</label>
                    <input type="number" id="num_clusters" name="num_clusters" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div id="dbscan_options" class="hidden">
                    <div>
                        <label for="dbscan_eps" class="block text-gray-400 text-sm font-bold mb-2">DBSCAN Epsilon (eps):</label>
                        <input type="number" step="0.01" id="dbscan_eps" name="dbscan_eps" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                    <div class="mt-2">
                        <label for="dbscan_min_samples" class="block text-gray-400 text-sm font-bold mb-2">DBSCAN Min Samples:</label>
                        <input type="number" id="dbscan_min_samples" name="dbscan_min_samples" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                    </div>
                </div>
                <div>
                    <label for="pca_components" class="block text-gray-400 text-sm font-bold mb-2">PCA Components (0 to disable):</label>
                    <input type="number" id="pca_components" name="pca_components" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="clustering_runs" class="block text-gray-400 text-sm font-bold mb-2">Clustering Runs (for diversity):</label>
                    <input type="number" id="clustering_runs" name="clustering_runs" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div>
                    <label for="max_songs_per_cluster" class="block text-gray-400 text-sm font-bold mb-2">Max Songs per Playlist/Cluster:</label>
                    <input type="number" id="max_songs_per_cluster" name="max_songs_per_cluster" class="shadow appearance-none border rounded w-full py-2 px-3 leading-tight focus:outline-none focus:shadow-outline">
                </div>
                <div class="col-span-1 md:col-span-2 mt-4 text-center">
                    <button type="submit" id="generatePlaylistsBtn" class="bg-green-500 hover:bg-green-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                        Generate Playlists
                    </button>
                    <button type="button" id="fetchPlaylistsBtn" class="bg-gray-500 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline ml-4">
                        Fetch Saved Playlists
                    </button>
                </div>
            </form>
        </div>

        <div id="clusteringProgressContainer" class="card p-6 mb-8 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Clustering Status</h2>
            <p class="text-lg mb-2 text-gray-300">Task ID: <span id="clusteringTaskIdDisplay" class="font-bold text-blue-400">N/A</span></p>
            <p class="text-lg mb-4 status-box" id="clusteringStatus">Status: Idle</p>
            <div class="w-full bg-gray-600 rounded-full h-4 mb-4">
                <div id="clusteringProgressBar" class="bg-blue-500 h-4 rounded-full" style="width: 0%"></div>
            </div>
            <h3 class="text-xl font-semibold mb-2 text-white">Clustering Log:</h3>
            <pre id="clusteringLogOutput" class="log-output"></pre>
            <div class="mt-4 text-center">
                   <button id="cancelClusteringBtn" class="bg-red-500 hover:bg-red-700 text-white font-bold py-2 px-4 rounded focus:outline-none focus:shadow-outline">
                    Cancel Clustering
                </button>
            </div>
        </div>


        <div id="playlistsDisplay" class="card p-6 hidden">
            <h2 class="text-2xl font-semibold mb-4 text-white">Generated Playlists</h2>
            <ul id="playlistList" class="playlist-list">
                </ul>
        </div>
    </div>

    <script>
        const API_BASE_URL = '/api';

        // Analysis elements
        const analysisForm = document.getElementById('analysisForm');
        const startAnalysisBtn = document.getElementById('startAnalysisBtn');
        const analysisProgressContainer = document.getElementById('analysisProgressContainer');
        const analysisTaskIdDisplay = document.getElementById('analysisTaskIdDisplay');
        const analysisStatus = document.getElementById('analysisStatus');
        const analysisProgressBar = document.getElementById('analysisProgressBar');
        const currentAlbumName = document.getElementById('currentAlbumName');
        const currentAlbumProgress = document.getElementById('currentAlbumProgress');
        const analysisLogOutput = document.getElementById('analysisLogOutput');
        const cancelAnalysisBtn = document.getElementById('cancelAnalysisBtn');

        // Playlist/Clustering elements
        const playlistForm = document.getElementById('playlistForm');
        const clusteringMethodSelect = document.getElementById('clustering_method');
        const kmeansOptions = document.getElementById('kmeans_options');
        const dbscanOptions = document.getElementById('dbscan_options');
        const playlistsDisplay = document.getElementById('playlistsDisplay');
        const playlistList = document.getElementById('playlistList');
        const fetchPlaylistsBtn = document.getElementById('fetchPlaylistsBtn');
        const generatePlaylistsBtn = document.getElementById('generatePlaylistsBtn'); // Added for disabling

        // Clustering Progress elements
        const clusteringProgressContainer = document.getElementById('clusteringProgressContainer');
        const clusteringTaskIdDisplay = document.getElementById('clusteringTaskIdDisplay');
        const clusteringStatus = document.getElementById('clusteringStatus');
        const clusteringProgressBar = document.getElementById('clusteringProgressBar');
        const clusteringLogOutput = document.getElementById('clusteringLogOutput');
        const cancelClusteringBtn = document.getElementById('cancelClusteringBtn');


        let pollingInterval = null;
        let currentTaskId = null;
        let currentTaskType = null; // To store 'analysis' or 'clustering'

        // --- Utility Functions ---

        function showProgressContainer(type, show = true) {
            if (type === 'analysis') {
                analysisProgressContainer.classList.toggle('hidden', !show);
            } else if (type === 'clustering') {
                clusteringProgressContainer.classList.toggle('hidden', !show);
            }
        }

        function setStatus(type, statusText, stateClass) {
            let statusElement;
            if (type === 'analysis') {
                statusElement = analysisStatus;
            } else if (type === 'clustering') {
                statusElement = clusteringStatus;
            }
            if (statusElement) {
                statusElement.textContent = `Status: ${statusText}`;
                statusElement.className = 'text-lg mb-4 status-box'; // Reset classes
                if (stateClass) {
                    statusElement.classList.add(`status-${stateClass}`); // Add state-specific class
                }
            }
        }

        function updateAnalysisProgress(data) {
            setStatus('analysis', data.status, data.state);
            analysisProgressBar.style.width = `${data.progress || 0}%`;
            currentAlbumName.textContent = data.current_album || 'N/A';
            currentAlbumProgress.textContent = `${data.current_album_idx || 0}/${data.total_albums || 0}`;
            if (Array.isArray(data.log_output)) {
                analysisLogOutput.textContent = data.log_output.join('\n');
            } else {
                analysisLogOutput.textContent = String(data.log_output || '');
            }
            analysisLogOutput.scrollTop = analysisLogOutput.scrollHeight;
        }

        function updateClusteringProgress(data) {
            setStatus('clustering', data.status, data.state);
            clusteringProgressBar.style.width = `${data.progress || 0}%`;
            if (Array.isArray(data.log_output)) {
                clusteringLogOutput.textContent = data.log_output.join('\n');
            } else {
                clusteringLogOutput.textContent = String(data.log_output || '');
            }
            clusteringLogOutput.scrollTop = clusteringLogOutput.scrollHeight;
        }

        async function pollStatus(taskId, taskType) {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
            showProgressContainer(taskType, true); // Ensure correct container is visible

            pollingInterval = setInterval(async () => {
                try {
                    const response = await fetch(`${API_BASE_URL}/status/${taskId}`);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const data = await response.json();

                    if (taskType === 'analysis') {
                        analysisTaskIdDisplay.textContent = data.task_id;
                        updateAnalysisProgress(data);
                    } else if (taskType === 'clustering') {
                        clusteringTaskIdDisplay.textContent = data.task_id;
                        updateClusteringProgress(data);
                    }

                    if (['SUCCESS', 'FAILURE', 'REVOKED'].includes(data.state)) {
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                        
                        // Re-enable all relevant buttons
                        startAnalysisBtn.disabled = false;
                        cancelAnalysisBtn.disabled = true;
                        generatePlaylistsBtn.disabled = false; 
                        cancelClusteringBtn.disabled = true;
                        fetchPlaylistsBtn.disabled = false; // Ensure fetch button is re-enabled

                        currentTaskId = null;
                        currentTaskType = null;

                        // If clustering was successful, fetch and display playlists
                        if (taskType === 'clustering' && data.state === 'SUCCESS') {
                            fetchPlaylists();
                        }

                    } else {
                        // Keep relevant buttons disabled if task is still in progress
                        startAnalysisBtn.disabled = true;
                        cancelAnalysisBtn.disabled = (taskType === 'analysis' ? false : true); // Only enable if it's the active task type
                        generatePlaylistsBtn.disabled = true;
                        cancelClusteringBtn.disabled = (taskType === 'clustering' ? false : true); // Only enable if it's the active task type
                        fetchPlaylistsBtn.disabled = true; // Disable fetch button during any active task
                    }
                } catch (error) {
                    console.error(`Error polling ${taskType} status:`, error);
                    setStatus(taskType, `Error polling: ${error.message || error}`, 'FAILURE'); // Changed 'type' to 'taskType'
                    clearInterval(pollingInterval);
                    pollingInterval = null;
                    
                    // Re-enable all relevant buttons on polling error
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                    generatePlaylistsBtn.disabled = false;
                    cancelClusteringBtn.disabled = true;
                    fetchPlaylistsBtn.disabled = false; // Ensure fetch button is re-enabled

                    currentTaskId = null;
                    currentTaskType = null;
                }
            }, 3000);
        }

        async function populateConfig() {
            try {
                const response = await fetch(`${API_BASE_URL}/config`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const config = await response.json();

                document.getElementById('jellyfin_url').value = config.jellyfin_url || '';
                document.getElementById('jellyfin_user_id').value = config.jellyfin_user_id || '';
                document.getElementById('jellyfin_token').value = config.jellyfin_token || '';
                document.getElementById('num_recent_albums').value = config.num_recent_albums !== undefined ? config.num_recent_albums : 0;
                document.getElementById('top_n_moods').value = config.top_n_moods !== undefined ? config.top_n_moods : 5;

                document.getElementById('clustering_method').value = config.cluster_algorithm || 'kmeans';
                document.getElementById('num_clusters').value = config.num_clusters !== undefined ? config.num_clusters : 40;
                document.getElementById('dbscan_eps').value = config.dbscan_eps !== undefined ? config.dbscan_eps : 0.15;
                document.getElementById('dbscan_min_samples').value = config.dbscan_min_samples !== undefined ? config.dbscan_min_samples : 10;
                document.getElementById('pca_components').value = config.pca_enabled ? 3 : 0;
                document.getElementById('clustering_runs').value = config.clustering_runs !== undefined ? config.clustering_runs : 10;
                // Populate new field
                document.getElementById('max_songs_per_cluster').value = config.max_songs_per_cluster !== undefined ? config.max_songs_per_cluster : 40;


                toggleClusteringOptions();
            } catch (error) {
                console.error("Failed to fetch initial configuration:", error);
                // Using a custom modal/dialog instead of alert for better UX
                const errorMessage = `Could not load initial configuration. Please check the backend API. Error: ${error.message}`;
                displayMessageModal(errorMessage, 'Error');
            }
        }

        function toggleClusteringOptions() {
            if (clusteringMethodSelect.value === 'kmeans') {
                kmeansOptions.classList.remove('hidden');
                dbscanOptions.classList.add('hidden');
            } else {
                kmeansOptions.classList.add('hidden');
                dbscanOptions.classList.remove('hidden');
            }
        }

        async function fetchLastAnalysisStatus() {
            try {
                const response = await fetch(`${API_BASE_URL}/last_task`);
                const data = await response.json();
                if (data.task_id && ['PENDING', 'PROGRESS', 'STARTED'].includes(data.status)) {
                    currentTaskId = data.task_id;
                    currentTaskType = data.task_type;

                    // Hide both containers initially, then show the relevant one
                    showProgressContainer('analysis', false);
                    showProgressContainer('clustering', false);

                    if (currentTaskType === 'analysis') {
                        analysisTaskIdDisplay.textContent = currentTaskId;
                        setStatus('analysis', data.status, data.status);
                        pollStatus(currentTaskId, currentTaskType);
                    } else if (currentTaskType === 'clustering') {
                        clusteringTaskIdDisplay.textContent = currentTaskId;
                        setStatus('clustering', data.status, data.status);
                        pollStatus(currentTaskId, currentTaskType);
                    }
                } else if (data.task_id) {
                    // If a task existed but finished, show its final status without polling
                    currentTaskId = data.task_id;
                    currentTaskType = data.task_type;

                    showProgressContainer('analysis', false);
                    showProgressContainer('clustering', false);

                    if (currentTaskType === 'analysis') {
                        analysisTaskIdDisplay.textContent = currentTaskId;
                        setStatus('analysis', data.status, data.status);
                        analysisProgressBar.style.width = '100%';
                        analysisLogOutput.textContent = `Previous analysis task (ID: ${currentTaskId}) finished with status: ${data.status}.`;
                    } else if (currentTaskType === 'clustering') {
                        clusteringTaskIdDisplay.textContent = currentTaskId;
                        setStatus('clustering', data.status, data.status);
                        clusteringProgressBar.style.width = '100%';
                        clusteringLogOutput.textContent = `Previous clustering task (ID: ${currentTaskId}) finished with status: ${data.status}.`;
                        if (data.status === 'SUCCESS') { // If clustering was successful, display playlists
                            fetchPlaylists();
                        }
                    }
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                    generatePlaylistsBtn.disabled = false;
                    cancelClusteringBtn.disabled = true;
                    fetchPlaylistsBtn.disabled = false; // Ensure fetch button is re-enabled
                } else {
                    // No previous task, hide both progress containers
                    showProgressContainer('analysis', false);
                    showProgressContainer('clustering', false);
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                    generatePlaylistsBtn.disabled = false;
                    cancelClusteringBtn.disabled = true;
                    fetchPlaylistsBtn.disabled = false; // Ensure fetch button is re-enabled
                }
            } catch (error) {
                console.error("Error fetching last task status:", error);
                showProgressContainer('analysis', false);
                showProgressContainer('clustering', false);
                startAnalysisBtn.disabled = false;
                cancelAnalysisBtn.disabled = true;
                generatePlaylistsBtn.disabled = false;
                cancelClusteringBtn.disabled = true;
                fetchPlaylistsBtn.disabled = false; // Ensure fetch button is re-enabled
            }
        }

        // Custom modal for messages (replaces alert/confirm)
        function displayMessageModal(message, type = 'Info', onConfirm = null) {
            const modalId = 'customMessageModal';
            let modal = document.getElementById(modalId);
            if (!modal) {
                modal = document.createElement('div');
                modal.id = modalId;
                modal.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50';
                modal.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full text-white">
                        <h3 class="text-xl font-bold mb-4" id="modalTitle"></h3>
                        <p class="mb-6" id="modalMessage"></p>
                        <div class="flex justify-end space-x-4">
                            <button id="modalCancelBtn" class="bg-gray-600 hover:bg-gray-700 text-white font-bold py-2 px-4 rounded">Cancel</button>
                            <button id="modalConfirmBtn" class="bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded">OK</button>
                        </div>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            document.getElementById('modalTitle').textContent = type;
            document.getElementById('modalMessage').textContent = message;

            const confirmBtn = document.getElementById('modalConfirmBtn');
            const cancelBtn = document.getElementById('modalCancelBtn');

            confirmBtn.onclick = () => {
                modal.classList.add('hidden');
                if (onConfirm) onConfirm(true);
            };

            if (onConfirm) { // If onConfirm is provided, it's a confirmation dialog
                cancelBtn.classList.remove('hidden');
                cancelBtn.onclick = () => {
                    modal.classList.add('hidden');
                    onConfirm(false);
                };
            } else { // Otherwise, it's just an info/error message
                cancelBtn.classList.add('hidden');
            }

            modal.classList.remove('hidden');
        }


        // --- Event Listeners ---

        analysisForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            startAnalysisBtn.disabled = true;
            generatePlaylistsBtn.disabled = true; // Disable clustering button too
            fetchPlaylistsBtn.disabled = true; // Disable fetch button
            cancelAnalysisBtn.disabled = false;
            cancelClusteringBtn.disabled = true; // Ensure clustering cancel is disabled

            analysisLogOutput.textContent = '';
            analysisProgressBar.style.width = '0%';
            currentAlbumName.textContent = 'N/A';
            currentAlbumProgress.textContent = '0/0';
            setStatus('analysis', 'Initiating...', 'PENDING');
            showProgressContainer('analysis', true);
            showProgressContainer('clustering', false); // Hide clustering progress

            const formData = new FormData(analysisForm);
            const data = Object.fromEntries(formData.entries());

            data.num_recent_albums = parseInt(data.num_recent_albums, 10);
            data.top_n_moods = parseInt(data.top_n_moods, 10);

            try {
                const response = await fetch(`${API_BASE_URL}/analysis/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                currentTaskId = result.task_id;
                currentTaskType = result.task_type;
                analysisTaskIdDisplay.textContent = currentTaskId;
                pollStatus(currentTaskId, currentTaskType);
                displayMessageModal("Analysis started successfully!", "Success");
            } catch (error) {
                console.error("Error starting analysis:", error);
                displayMessageModal(`Failed to start analysis: ${error.message || error}`, "Error");
                setStatus('analysis', 'Failed to start', 'FAILURE');
                startAnalysisBtn.disabled = false;
                generatePlaylistsBtn.disabled = false;
                fetchPlaylistsBtn.disabled = false; // Re-enable fetch button
                cancelAnalysisBtn.disabled = true;
                showProgressContainer('analysis', false);
            }
        });

        cancelAnalysisBtn.addEventListener('click', () => {
            if (!currentTaskId || currentTaskType !== 'analysis') {
                displayMessageModal("No active analysis to cancel.", "Info");
                return;
            }

            displayMessageModal(`Are you sure you want to cancel analysis task ${currentTaskId}?`, 'Confirm', async (confirmed) => {
                if (!confirmed) {
                    return;
                }

                try {
                    const response = await fetch(`${API_BASE_URL}/cancel/${currentTaskId}`, {
                        method: 'POST'
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                    }
                    const result = await response.json();
                    displayMessageModal(result.message, "Success");
                    if (pollingInterval) {
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                    }
                    setStatus('analysis', 'Cancelled', 'REVOKED');
                    startAnalysisBtn.disabled = false;
                    cancelAnalysisBtn.disabled = true;
                    generatePlaylistsBtn.disabled = false;
                    cancelClusteringBtn.disabled = true;
                    fetchPlaylistsBtn.disabled = false; // Re-enable fetch button
                    currentTaskId = null;
                    currentTaskType = null;
                } catch (error) {
                    console.error("Error cancelling analysis:", error);
                    displayMessageModal(`Failed to cancel analysis: ${error.message || error}`, "Error");
                }
            });
        });


        playlistForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            generatePlaylistsBtn.disabled = true;
            fetchPlaylistsBtn.disabled = true;
            startAnalysisBtn.disabled = true; // Disable analysis button too
            cancelClusteringBtn.disabled = false;
            cancelAnalysisBtn.disabled = true; // Ensure analysis cancel is disabled

            clusteringLogOutput.textContent = ''; // Clear previous logs
            clusteringProgressBar.style.width = '0%';
            setStatus('clustering', 'Initiating...', 'PENDING');
            showProgressContainer('clustering', true);
            showProgressContainer('analysis', false); // Hide analysis progress


            const formData = new FormData(playlistForm);
            const data = Object.fromEntries(formData.entries());

            data.num_clusters = parseInt(data.num_clusters, 10);
            data.dbscan_eps = parseFloat(data.dbscan_eps);
            data.dbscan_min_samples = parseInt(data.dbscan_min_samples, 10);
            const pca_components = parseInt(data.pca_components, 10);
            data.pca_enabled = pca_components > 0;
            if (!data.pca_enabled) {
                delete data.pca_components;
            }
            data.clustering_runs = parseInt(data.clustering_runs, 10);
            // Get new field value
            data.max_songs_per_cluster = parseInt(data.max_songs_per_cluster, 10);

            try {
                const response = await fetch(`${API_BASE_URL}/clustering/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(data)
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                }
                const result = await response.json();
                currentTaskId = result.task_id;
                currentTaskType = result.task_type;
                clusteringTaskIdDisplay.textContent = currentTaskId;
                pollStatus(currentTaskId, currentTaskType);
                displayMessageModal("Clustering started successfully!", "Success");
            } catch (error) {
                console.error("Error generating playlists:", error);
                displayMessageModal(`Failed to generate playlists: ${error.message || error}`, "Error");
                setStatus('clustering', 'Failed to start', 'FAILURE');
                generatePlaylistsBtn.disabled = false;
                fetchPlaylistsBtn.disabled = false;
                startAnalysisBtn.disabled = false;
                cancelClusteringBtn.disabled = true;
                showProgressContainer('clustering', false);
            }
        });

        cancelClusteringBtn.addEventListener('click', () => {
            if (!currentTaskId || currentTaskType !== 'clustering') {
                displayMessageModal("No active clustering to cancel.", "Info");
                return;
            }

            displayMessageModal(`Are you sure you want to cancel clustering task ${currentTaskId}?`, 'Confirm', async (confirmed) => {
                if (!confirmed) {
                    return;
                }

                try {
                    const response = await fetch(`${API_BASE_URL}/cancel/${currentTaskId}`, {
                        method: 'POST'
                    });
                    if (!response.ok) {
                        const errorData = await response.json();
                        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
                    }
                    const result = await response.json();
                    displayMessageModal(result.message, "Success");
                    if (pollingInterval) {
                        clearInterval(pollingInterval);
                        pollingInterval = null;
                    }
                    setStatus('clustering', 'Cancelled', 'REVOKED');
                    generatePlaylistsBtn.disabled = false;
                    fetchPlaylistsBtn.disabled = false;
                    startAnalysisBtn.disabled = false;
                    cancelClusteringBtn.disabled = true;
                    currentTaskId = null;
                    currentTaskType = null;
                } catch (error) {
                    console.error("Error cancelling clustering:", error);
                    displayMessageModal(`Failed to cancel clustering: ${error.message || error}`, "Error");
                }
            });
        });


        clusteringMethodSelect.addEventListener('change', toggleClusteringOptions);

        async function fetchPlaylists() {
            playlistsDisplay.classList.add('hidden');
            playlistList.innerHTML = ''; // Clear existing list
            try {
                const response = await fetch(`${API_BASE_URL}/playlists`);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const playlists = await response.json();
                if (Object.keys(playlists).length === 0) {
                    playlistList.innerHTML = '<li class="text-center text-gray-400">No playlists found. Run analysis and generate playlists first.</li>';
                } else {
                    for (const playlistName in playlists) {
                        const li = document.createElement('li');
                        const toggleBtn = document.createElement('button');
                        toggleBtn.className = 'playlist-toggle';
                        toggleBtn.textContent = 'Show Tracks';
                        
                        const h3 = document.createElement('h3');
                        h3.innerHTML = `${playlistName} (${playlists[playlistName].length} tracks) `;
                        h3.appendChild(toggleBtn); // Append button to h3

                        const tracksDiv = document.createElement('div');
                        tracksDiv.className = 'playlist-tracks hidden'; // Hidden by default
                        playlists[playlistName].forEach(track => {
                            const p = document.createElement('p');
                            p.textContent = `${track.title} by ${track.author}`;
                            tracksDiv.appendChild(p);
                        });
                        
                        li.appendChild(h3); // Append h3 (which contains the button) to li
                        li.appendChild(tracksDiv); // Append tracksDiv to li

                        // Corrected onclick function to reference tracksDiv via its parent (li)
                        toggleBtn.onclick = function() {
                            // 'this' refers to the toggleBtn
                            // 'this.closest("li")' finds the nearest parent <li> element
                            // 'tracksDiv' is the second child of the <li> (after the h3)
                            const parentLi = this.closest("li");
                            if (parentLi) {
                                const tracksDiv = parentLi.querySelector('.playlist-tracks'); // Find tracksDiv within this specific li
                                if (tracksDiv) {
                                    if (tracksDiv.classList.contains('hidden')) {
                                        tracksDiv.classList.remove('hidden');
                                        this.textContent = 'Hide Tracks';
                                    } else {
                                        tracksDiv.classList.add('hidden');
                                        this.textContent = 'Show Tracks';
                                    }
                                } else {
                                    console.error("Could not find tracksDiv for playlist toggle button in parent li:", parentLi);
                                }
                            } else {
                                console.error("Could not find parent li for playlist toggle button:", this);
                            }
                        };


                        playlistList.appendChild(li);
                    }
                }
                playlistsDisplay.classList.remove('hidden');
            } catch (error) {
                console.error("Error fetching playlists:", error);
                playlistList.innerHTML = `<li class="text-center text-red-400">Failed to load playlists: ${error.message}</li>`;
                playlistsDisplay.classList.remove('hidden');
            }
        }

        fetchPlaylistsBtn.addEventListener('click', fetchPlaylists);

        // --- Initial Load ---
        document.addEventListener('DOMContentLoaded', async () => {
            await populateConfig();
            await fetchLastAnalysisStatus(); // Check for ongoing or last task
        });
    </script>
</body>
</html>
