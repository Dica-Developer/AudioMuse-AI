<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="app-version" content="{{ app_version }}">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AudioMuse-AI - Alternative Song Universe (Graph View)</title>
    <link rel="stylesheet" href="/static/style.css">
    <link rel="stylesheet" href="/static/menu.css">
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        /* Alternative Universe specific styles */
        .universe-container {
            position: relative;
            width: 100%;
            height: 100vh;
            background: #0a0a0a;
        }

        .search-panel {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            background: rgba(0,0,0,0.9);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.2);
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-group {
            display: flex;
            flex-direction: column;
            position: relative;
        }

        .search-input {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 5px;
            width: 150px;
            font-size: 14px;
        }

        .search-input::placeholder {
            color: rgba(255,255,255,0.6);
        }

        .search-label {
            color: white;
            font-size: 12px;
            margin-bottom: 4px;
            font-weight: 500;
        }

        /* Autocomplete styles */
        .autocomplete-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.95);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 5px;
            max-height: 300px;
            overflow-y: auto;
            z-index: 2000;
            margin-top: 2px;
        }

        .autocomplete-item {
            padding: 10px 12px;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.1);
            color: white;
        }

        .autocomplete-item:hover {
            background: rgba(255,255,255,0.1);
        }

        .autocomplete-item .title {
            font-weight: bold;
            color: #ffeb3b;
            font-size: 13px;
        }

        .autocomplete-item .artist {
            font-size: 11px;
            color: #e0e0e0;
            margin-top: 2px;
        }

        .hidden {
            display: none;
        }

        .search-btn {
            background: linear-gradient(45deg, #2196F3, #21CBF3);
            border: none;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .search-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(33, 150, 243, 0.4);
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            color: white;
            font-size: 18px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255,255,255,0.1);
            border-color: rgba(255,255,255,0.8);
            transform: scale(1.1);
        }

        .info-panel {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 1000;
            background: rgba(0,0,0,0.9);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            max-width: 300px;
            display: none;
            box-shadow: 0 4px 20px rgba(0,0,0,0.6);
        }

        .info-panel h3 {
            color: #ffeb3b;
            margin: 0 0 8px 0;
            font-size: 16px;
        }

        .info-panel p {
            color: #e0e0e0;
            margin: 0;
            line-height: 1.4;
            font-size: 14px;
        }

        /* Plotly container */
        #plotly-graph {
            width: 100%;
            height: 100vh;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            backdrop-filter: blur(5px);
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-spinner {
            border: 3px solid rgba(255,255,255,0.3);
            border-top: 3px solid #ffeb3b;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>

<div class="page-container">
    <aside class="sidebar">
        <nav>
            <ul class="sidebar-nav">
                <!-- Menu items are dynamically inserted by menu.js -->
            </ul>
        </nav>
    </aside>

    <div class="main-content" id="main-content">
        <button class="menu-toggle">&#9776;</button>
        
        <!-- Search Panel -->
        <div class="search-panel">
            <div class="search-group">
                <label class="search-label">Artist</label>
                <input type="text" class="search-input" id="artist_search" placeholder="Start typing artist..." autocomplete="off">
            </div>
            
            <div class="search-group">
                <label class="search-label">Title</label>
                <div style="position: relative;">
                    <input type="text" class="search-input" id="title_search" placeholder="Start typing title..." autocomplete="off">
                    <div id="autocomplete-results" class="autocomplete-results hidden"></div>
                </div>
            </div>
            
            <button class="search-btn" id="search-btn">Search & Visualize</button>
            
            <input type="hidden" id="selected_item_id">
        </div>

        <!-- Universe Container -->
        <div class="universe-container">
            <div id="plotly-graph"></div>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div class="control-btn" id="reset-view-btn" title="Reset View">‚åÇ</div>
            <div class="control-btn" id="toggle-connections-btn" title="Toggle Connections">‚ö°</div>
            <div class="control-btn" id="toggle-labels-btn" title="Toggle Labels">üìù</div>
        </div>

        <!-- Info Panel -->
        <div class="info-panel" id="info-panel">
            <h3 id="info-title"></h3>
            <p id="info-content"></p>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay hidden" id="loading-overlay">
            <div class="loading-content">
                <div class="loading-spinner"></div>
                <h3>Loading Song Universe...</h3>
                <p id="loading-message">Fetching data from voyager index...</p>
            </div>
        </div>
    </div>
</div>

<script>
console.log('Alternative Universe JavaScript loading...');

(() => {
    // Test basic functionality
    console.log('IIFE started');
    console.log('Plotly available:', typeof Plotly);
    
    // State variables
    let currentGraph = null;
    let allNodes = [];
    let allEdges = [];
    let visibleNodes = [];
    let visibleEdges = [];
    let searchTimeout;
    let showConnections = true;
    let showLabels = false;
    let viewport = { center: [0, 0], zoom: 1 };

    // DOM elements
    const artistInput = document.getElementById('artist_search');
    const titleInput = document.getElementById('title_search');
    const selectedItemIdInput = document.getElementById('selected_item_id');
    const autocompleteResults = document.getElementById('autocomplete-results');
    const infoPanel = document.getElementById('info-panel');
    const loadingOverlay = document.getElementById('loading-overlay');
    const loadingMessage = document.getElementById('loading-message');

    // Initialize the application
    function init() {
        console.log('Initializing Alternative Universe...');
        
        // Check if required elements exist
        if (!artistInput || !titleInput || !selectedItemIdInput || !autocompleteResults || !infoPanel || !loadingOverlay || !loadingMessage) {
            console.error('Missing required DOM elements');
            return;
        }
        
        setupSearchAutocomplete();
        setupPlotlyGraph();
        setupEventListeners();
        showInfo('Alternative Song Universe', 'Search for a song to visualize it and its similar songs in the network graph.');
        
        console.log('Alternative Universe initialized successfully');
    }

    // Setup event listeners for buttons
    function setupEventListeners() {
        console.log('Setting up event listeners...');
        
        // Search button
        const searchBtn = document.getElementById('search-btn');
        const resetBtn = document.getElementById('reset-view-btn');
        const toggleConnBtn = document.getElementById('toggle-connections-btn');
        const toggleLabelsBtn = document.getElementById('toggle-labels-btn');
        
        if (searchBtn) searchBtn.addEventListener('click', searchAndLoadGraph);
        if (resetBtn) resetBtn.addEventListener('click', resetView);
        if (toggleConnBtn) toggleConnBtn.addEventListener('click', toggleConnections);
        if (toggleLabelsBtn) toggleLabelsBtn.addEventListener('click', toggleLabels);
        
        console.log('Event listeners setup complete');
    }

    // Setup search autocomplete functionality
    function setupSearchAutocomplete() {
        const handleSearchInput = () => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(async () => {
                const artistQuery = artistInput.value.trim();
                const titleQuery = titleInput.value.trim();

                if (artistQuery.length < 3 && titleQuery.length < 3) {
                    hideAutocomplete();
                    return;
                }

                try {
                    const params = new URLSearchParams({ artist: artistQuery, title: titleQuery });
                    const response = await fetch(`/api/search_tracks?${params}`);
                    const tracks = await response.json();
                    showAutocomplete(tracks);
                } catch (error) {
                    console.error('Autocomplete search error:', error);
                    hideAutocomplete();
                }
            }, 300);
        };
        
        const showAutocomplete = (tracks) => {
            autocompleteResults.innerHTML = '';
            if (tracks.length === 0) {
                autocompleteResults.innerHTML = '<div class="autocomplete-item"><em>No results found</em></div>';
            } else {
                tracks.forEach(track => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'autocomplete-item';
                    itemDiv.innerHTML = `<div class="title">${track.title}</div><div class="artist">${track.author}</div>`;
                    itemDiv.addEventListener('click', () => selectTrack(track));
                    autocompleteResults.appendChild(itemDiv);
                });
            }
            autocompleteResults.classList.remove('hidden');
        };

        const hideAutocomplete = () => {
            autocompleteResults.classList.add('hidden');
        };

        const selectTrack = (track) => {
            artistInput.value = track.author;
            titleInput.value = track.title;
            selectedItemIdInput.value = track.item_id;
            hideAutocomplete();
        };

        artistInput.addEventListener('input', handleSearchInput);
        titleInput.addEventListener('input', handleSearchInput);
        
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.search-group')) {
                hideAutocomplete();
            }
        });
    }

    // Setup initial Plotly graph
    function setupPlotlyGraph() {
        console.log('Setting up Plotly graph...');
        console.log('Plotly available:', typeof Plotly !== 'undefined');
        
        const layout = {
            title: {
                text: 'Song Universe - Connected Graph',
                font: { color: 'white', size: 24 }
            },
            paper_bgcolor: '#000000',  // Pure black background
            plot_bgcolor: '#000000',   // Pure black plot area
            font: { color: 'white' },
            showlegend: false,
            hovermode: 'closest',
            xaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false,
                title: '',
                color: 'white'
            },
            yaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false,
                title: '',
                color: 'white'
            },
            margin: { l: 0, r: 0, t: 50, b: 0 },
            dragmode: 'pan'
        };

        const config = {
            responsive: true,
            displayModeBar: true,
            modeBarButtonsToRemove: ['select2d', 'lasso2d', 'autoScale2d'],
            modeBarButtonsToAdd: ['pan2d', 'zoom2d', 'zoomIn2d', 'zoomOut2d', 'resetScale2d'],
            displaylogo: false
        };

        // Initialize empty plot
        try {
            Plotly.newPlot('plotly-graph', [], layout, config);
            console.log('Initial Plotly graph created');
            
            // Add click event listener
            const plotlyDiv = document.getElementById('plotly-graph');
            plotlyDiv.on('plotly_click', function(data) {
                console.log('Plotly click event:', data);
                if (data.points.length > 0) {
                    const point = data.points[0];
                    const nodeData = point.customdata;
                    if (nodeData) {
                        console.log('Clicked node:', nodeData);
                        showSongInfo(nodeData);
                        highlightSongAndNeighbors(nodeData.item_id);
                    }
                }
            });
            
        } catch (error) {
            console.error('Error setting up Plotly graph:', error);
            showInfo('Setup Error', `Failed to initialize graph: ${error.message}`);
        }
    }

    // Process raw graph data into Plotly format
    async function processGraphData() {
        return new Promise(resolve => {
            // Create node positions using a simple force-directed layout simulation
            const nodePositions = calculateNodePositions(allNodes, allEdges);
            
            visibleNodes = allNodes.map((node, i) => ({
                ...node,
                x: nodePositions[i].x,
                y: nodePositions[i].y
            }));
            
            visibleEdges = allEdges;
            resolve();
        });
    }

    // Simple force-directed layout calculation
    function calculateNodePositions(nodes, edges) {
        const positions = nodes.map(() => ({
            x: (Math.random() - 0.5) * 200, // Spread nodes over larger area
            y: (Math.random() - 0.5) * 200
        }));

        // Simple spring-force simulation (simplified version)
        for (let iteration = 0; iteration < 100; iteration++) { // More iterations for better spacing
            // Repulsion between nodes
            for (let i = 0; i < positions.length; i++) {
                for (let j = i + 1; j < positions.length; j++) {
                    const dx = positions[i].x - positions[j].x;
                    const dy = positions[i].y - positions[j].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
                    const force = 500 / (dist * dist); // Stronger repulsion force
                    
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    
                    positions[i].x += fx * 0.2;
                    positions[i].y += fy * 0.2;
                    positions[j].x -= fx * 0.2;
                    positions[j].y -= fy * 0.2;
                }
            }

            // Attraction along edges
            edges.forEach(edge => {
                const sourceIdx = nodes.findIndex(n => n.item_id === edge.source);
                const targetIdx = nodes.findIndex(n => n.item_id === edge.target);
                
                if (sourceIdx >= 0 && targetIdx >= 0) {
                    const dx = positions[targetIdx].x - positions[sourceIdx].x;
                    const dy = positions[targetIdx].y - positions[sourceIdx].y;
                    const dist = Math.sqrt(dx * dx + dy * dy) + 0.1;
                    const force = dist * 0.02; // Stronger attraction
                    
                    const fx = (dx / dist) * force;
                    const fy = (dy / dist) * force;
                    
                    positions[sourceIdx].x += fx;
                    positions[sourceIdx].y += fy;
                    positions[targetIdx].x -= fx;
                    positions[targetIdx].y -= fy;
                }
            });
        }

        return positions;
    }

    // Render the graph using Plotly
    function renderGraph() {
        console.log('Rendering graph...');
        console.log('Visible nodes:', visibleNodes.length);
        console.log('Visible edges:', visibleEdges.length);
        
        const traces = [];

        // Add edges (connections) if enabled
        if (showConnections && visibleEdges.length > 0) {
            console.log('Adding edge trace...');
            const edgeTrace = {
                x: [],
                y: [],
                mode: 'lines',
                line: { 
                    width: 1.5,  // Thinner but still visible
                    color: 'rgba(255,255,255,0.6)'  // Bright white connections
                },
                hoverinfo: 'none',
                type: 'scatter',
                showlegend: false
            };

            visibleEdges.forEach(edge => {
                const sourceNode = visibleNodes.find(n => n.item_id === edge.source);
                const targetNode = visibleNodes.find(n => n.item_id === edge.target);
                
                if (sourceNode && targetNode) {
                    edgeTrace.x.push(sourceNode.x, targetNode.x, null);
                    edgeTrace.y.push(sourceNode.y, targetNode.y, null);
                }
            });

            console.log('Edge trace points:', edgeTrace.x.length);
            traces.push(edgeTrace);
        }

        // Add nodes
        console.log('Adding node trace...');
        const nodeTrace = {
            x: visibleNodes.map(n => n.x),
            y: visibleNodes.map(n => n.y),
            mode: 'markers',
            marker: {
                size: visibleNodes.map(n => {
                    if (n.is_center) return 40; // HUGE center song
                    return 25; // Very large circles for all songs
                }),
                color: visibleNodes.map(n => n.genre_color || '#ffeb3b'),
                line: { 
                    width: 4, // Very thick white border
                    color: 'white' 
                },
                opacity: 1 // Full opacity
            },
            text: visibleNodes.map(n => ''), // No permanent text labels
            textposition: 'top center',
            textfont: { color: 'white', size: 10 },
            hoverinfo: 'text',
            hovertext: visibleNodes.map(n => 
                `<b>${n.title}</b><br>` +
                `<i>by ${n.author}</i><br>` +
                `Genre: ${n.genre || 'Unknown'}<br>` +
                `Connections: ${n.connections || 0}` +
                (n.is_center ? '<br><b>üéØ CENTER SONG</b>' : '') +
                (n.distance_from_center ? `<br>Distance: ${n.distance_from_center.toFixed(3)}` : '')
            ),
            hoverlabel: {
                bgcolor: 'rgba(0,0,0,0.8)',
                bordercolor: 'white',
                font: { color: 'white', size: 12 }
            },
            customdata: visibleNodes,
            type: 'scatter',
            showlegend: false
        };

        traces.push(nodeTrace);
        console.log('Total traces:', traces.length);

        const layout = {
            title: {
                text: `Song Universe - ${visibleNodes.length} Songs`,
                font: { color: 'white', size: 20 }
            },
            paper_bgcolor: '#000000',  // Pure black
            plot_bgcolor: '#000000',   // Pure black
            font: { color: 'white' },
            showlegend: false,
            hovermode: 'closest',
            xaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false,
                title: '',
                color: 'white'
            },
            yaxis: {
                showgrid: false,
                zeroline: false,
                showticklabels: false,
                title: '',
                color: 'white'
            },
            margin: { l: 20, r: 20, t: 60, b: 20 },
            dragmode: 'pan'
        };

        console.log('Calling Plotly.react...');
        try {
            Plotly.react('plotly-graph', traces, layout);
            console.log('Plotly.react completed successfully');
        } catch (error) {
            console.error('Error in Plotly.react:', error);
            showInfo('Rendering Error', `Failed to render graph: ${error.message}`);
        }
    }

    // Search and load graph centered on the selected song
    async function searchAndLoadGraph() {
        console.log('Search and load graph triggered');
        const selectedItemId = selectedItemIdInput.value;
        
        console.log('Selected item ID:', selectedItemId);
        
        if (!selectedItemId) {
            showInfo('Search Error', 'Please select a song from the autocomplete suggestions.');
            return;
        }

        showLoading('Loading song network...');
        
        try {
            // Load graph centered on the selected song
            loadingMessage.textContent = 'Fetching similar songs...';
            console.log('Fetching graph data centered on song:', selectedItemId);
            
            const response = await fetch(`/api/universe/graph_data_centered?item_id=${encodeURIComponent(selectedItemId)}&limit=100`);
            console.log('Response status:', response.status);
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Server error:', errorText);
                throw new Error(`HTTP ${response.status}: ${errorText}`);
            }
            
            const graphData = await response.json();
            console.log('Graph data received:', graphData);
            
            allNodes = graphData.nodes || [];
            allEdges = graphData.edges || [];
            
            console.log(`Loaded ${allNodes.length} nodes and ${allEdges.length} edges`);
            
            if (allNodes.length === 0) {
                hideLoading();
                showInfo('No Data', 'No similar songs found for the selected track.');
                return;
            }

            loadingMessage.textContent = `Processing ${allNodes.length} songs and ${allEdges.length} connections...`;
            
            // Process the graph data for Plotly
            await processGraphData();
            
            loadingMessage.textContent = 'Rendering graph...';
            console.log('Rendering graph with Plotly...');
            renderGraph();
            
            // Auto-fit the view to show all nodes
            setTimeout(() => {
                Plotly.relayout('plotly-graph', {
                    'xaxis.autorange': true,
                    'yaxis.autorange': true
                });
            }, 100);
            
            // Highlight the searched song
            const centerSong = visibleNodes.find(n => n.item_id === selectedItemId);
            if (centerSong) {
                setTimeout(() => {
                    highlightSongAndNeighbors(selectedItemId);
                    showSongInfo(centerSong);
                }, 200);
            }
            
            hideLoading();
            showInfo('Graph Loaded', `Loaded ${allNodes.length} songs centered on "${centerSong ? centerSong.title : 'your search'}" with ${allEdges.length} connections.`);
            
        } catch (error) {
            hideLoading();
            console.error('Error loading graph:', error);
            showInfo('Error', `Failed to load graph: ${error.message}`);
        }
    }

    // Highlight a song and its neighbors
    function highlightSongAndNeighbors(songId) {
        // Find connected songs
        const connectedIds = new Set([songId]);
        visibleEdges.forEach(edge => {
            if (edge.source === songId) connectedIds.add(edge.target);
            if (edge.target === songId) connectedIds.add(edge.source);
        });

        // Update node colors and sizes
        const nodeTrace = {
            x: visibleNodes.map(n => n.x),
            y: visibleNodes.map(n => n.y),
            mode: 'markers',
            marker: {
                size: visibleNodes.map(n => {
                    if (n.item_id === songId) return 50; // MASSIVE selected song
                    if (n.is_center) return 45; // Very large center song
                    if (connectedIds.has(n.item_id)) return 35; // Large connected songs
                    return 20; // Still large for unconnected songs
                }),
                color: visibleNodes.map(n => {
                    if (n.item_id === songId) return '#ff0066'; // Bright pink for selected
                    if (n.is_center && n.item_id !== songId) return '#ff4444'; // Red for center
                    if (connectedIds.has(n.item_id)) return '#44ff44'; // Green for connected
                    return n.genre_color || '#ffeb3b'; // Default color for others
                }),
                line: { 
                    width: visibleNodes.map(n => connectedIds.has(n.item_id) ? 6 : 4), // Very thick borders
                    color: visibleNodes.map(n => connectedIds.has(n.item_id) ? 'yellow' : 'white') 
                },
                opacity: 1 // Always full opacity
            },
            text: visibleNodes.map(n => ''), // No permanent labels
            textposition: 'top center',
            textfont: { color: 'white', size: 10 },
            hoverinfo: 'text',
            hovertext: visibleNodes.map(n => 
                `<b>${n.title}</b><br>` +
                `<i>by ${n.author}</i><br>` +
                `Genre: ${n.genre || 'Unknown'}<br>` +
                `Connections: ${n.connections || 0}` +
                (n.is_center ? '<br><b>üéØ CENTER SONG</b>' : '') +
                (n.item_id === songId ? '<br><b>üîç SELECTED</b>' : '') +
                (n.distance_from_center ? `<br>Distance: ${n.distance_from_center.toFixed(3)}` : '')
            ),
            hoverlabel: {
                bgcolor: 'rgba(0,0,0,0.8)',
                bordercolor: 'white',
                font: { color: 'white', size: 12 }
            },
            customdata: visibleNodes,
            type: 'scatter',
            showlegend: false
        };

        Plotly.restyle('plotly-graph', nodeTrace, [showConnections ? 1 : 0]);
    }

    // Pan to a specific node
    function panToNode(node) {
        const update = {
            'xaxis.range': [node.x - 20, node.x + 20],
            'yaxis.range': [node.y - 20, node.y + 20]
        };
        Plotly.relayout('plotly-graph', update);
    }

    // Show song information
    function showSongInfo(song) {
        showInfo(`‚ô™ ${song.title}`, `by ${song.author}<br>Connections: ${song.connections || 0}<br>Genre: ${song.genre || 'Unknown'}`);
    }

    // Control functions
    function resetView() {
        Plotly.relayout('plotly-graph', {
            'xaxis.autorange': true,
            'yaxis.autorange': true
        });
        renderGraph(); // Reset highlighting and restore original appearance
    }

    function toggleConnections() {
        showConnections = !showConnections;
        renderGraph();
        showInfo('Connections', showConnections ? 'Connections enabled' : 'Connections disabled');
    }

    function toggleLabels() {
        showLabels = !showLabels;
        renderGraph();
        showInfo('Labels', showLabels ? 'Labels enabled' : 'Labels disabled');
    }

    // Utility functions
    function showLoading(message) {
        loadingMessage.textContent = message;
        loadingOverlay.classList.remove('hidden');
    }

    function hideLoading() {
        loadingOverlay.classList.add('hidden');
    }

    function showInfo(title, content) {
        document.getElementById('info-title').textContent = title;
        document.getElementById('info-content').innerHTML = content;
        infoPanel.style.display = 'block';
    }

    function hideInfo() {
        infoPanel.style.display = 'none';
    }

    // Initialize the application
    init();
    
    // Make functions globally available as fallback (for debugging)
    window.searchAndLoadGraph = searchAndLoadGraph;
    window.resetView = resetView;
    window.toggleConnections = toggleConnections;
    window.toggleLabels = toggleLabels;
    
    console.log('Functions made globally available for debugging');
})();

// Also initialize when DOM is fully loaded (fallback)
document.addEventListener('DOMContentLoaded', function() {
    console.log('DOM Content Loaded - Alternative Universe');
});
</script>

<script src="/static/menu.js"></script>
</body>
</html>