name: Build, Test, and Push AudioMuse AI Docker Image

on:
  push:
    branches:
      - devel-librosa # Trigger only for 'devel-librosa' branch

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    permissions:
      contents: read # Allow checkout to read repository contents
      packages: write # Allow pushing to GitHub Container Registry

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3 # Essential for multi-architecture builds

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Docker image tags
        id: docker_tags
        run: |
          REPO_NAME_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          ALL_TAGS=""

          if [[ "${GITHUB_REF}" == "refs/heads/devel-librosa" ]]; then
            DEV_LIBROSA_TAG="ghcr.io/$REPO_NAME_LOWER:devel-librosa"
            ALL_TAGS="$DEV_LIBROSA_TAG"
            echo "Building devel-librosa tag: $DEV_LIBROSA_TAG"

          elif [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            VERSION_TAG=$(echo "${GITHUB_REF}" | sed -e 's|refs/tags/v||g')
            VERSIONED_TAG="ghcr.io/$REPO_NAME_LOWER:${VERSION_TAG}"
            ALL_TAGS="$VERSIONED_TAG"
            echo "Building versioned tag: $VERSIONED_TAG"
          fi

          # Export the main tags for subsequent steps
          echo "docker_tags=$ALL_TAGS" >> "$GITHUB_OUTPUT"
          # Export a unique temporary tag for internal multi-architecture testing
          echo "test_tag=ghcr.io/$REPO_NAME_LOWER:test-temp-${GITHUB_RUN_ID}" >> "$GITHUB_OUTPUT"

      - name: Build and Push Docker image (for multi-arch testing)
        id: docker_build_test
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64 # Build for both Intel and ARM architectures
          push: true # Push the temporary image to the registry for testing
          tags: ${{ steps.docker_tags.outputs.test_tag }}

      - name: Run Flask App Container Health Check (AMD64)
        run: |
          echo "Starting temporary PostgreSQL container for Flask test (AMD64)..."
          docker run -d --name postgres-flask-test-amd64 --platform linux/amd64 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            postgres:latest # Changed to postgres:latest for better compatibility

          echo "Waiting for PostgreSQL (Flask test AMD64) to start..."
          for i in $(seq 1 120); do
            if docker exec postgres-flask-test-amd64 pg_isready -U testuser -d testdb -q; then
              echo "PostgreSQL (Flask test AMD64) is ready."
              break
            fi
            echo "Waiting for PostgreSQL (Flask test AMD64)... ($i/30)"
            sleep 2
            if [ $i -eq 120 ]; then
              echo "PostgreSQL (Flask test AMD64) did not become ready in time."
              docker logs postgres-flask-test-amd64
              exit 1
            fi
          done

          echo "Starting Flask app container for health check (AMD64)..."
          docker run -d --name flask-test-app-amd64 -p 8000:8000 --platform linux/amd64 \
            --link postgres-flask-test-amd64:postgres \
            -e SERVICE_TYPE=flask \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            -e POSTGRES_HOST=postgres \
            -e POSTGRES_PORT=5432 \
            ${{ steps.docker_tags.outputs.test_tag }}

          echo "Waiting for Flask app (AMD64) to start (max 60 seconds)..."
          for i in $(seq 1 60); do
            if curl -sf -I http://localhost:8000/api/last_task | grep -qE "HTTP/[12](.[01])? (2|3)[0-9]{2}"; then
              echo "Flask app (AMD64) is up and responsive!"
              exit 0
            fi
            echo "Waiting... ($i/60)"
            sleep 1
          done
          echo "Flask app (AMD64) did not start or respond with a successful status on /api/last_task within the expected time."
          docker logs flask-test-app-amd64
          exit 1

      - name: Run Flask App Container Health Check (ARM64)
        run: |
          echo "Starting temporary PostgreSQL container for Flask test (ARM64)..."
          docker run -d --name postgres-flask-test-arm64 --platform linux/arm64 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            postgres:latest # Changed to postgres:latest for better compatibility

          echo "Waiting for PostgreSQL (Flask test ARM64) to start..."
          for i in $(seq 1 120); do
            if docker exec postgres-flask-test-arm64 pg_isready -U testuser -d testdb -q; then
              echo "PostgreSQL (Flask test ARM64) is ready."
              break
            fi
            echo "Waiting for PostgreSQL (Flask test ARM64)... ($i/30)"
            sleep 2
            if [ $i -eq 120 ]; then
              echo "PostgreSQL (Flask test ARM64) did not become ready in time."
              docker logs postgres-flask-test-arm64
              exit 1
            fi
          done

          echo "Starting Flask app container for health check (ARM64)..."
          docker run -d --name flask-test-app-arm64 -p 8001:8000 --platform linux/arm64 \
            --link postgres-flask-test-arm64:postgres \
            -e SERVICE_TYPE=flask \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            -e POSTGRES_HOST=postgres \
            -e POSTGRES_PORT=5432 \
            ${{ steps.docker_tags.outputs.test_tag }}

          echo "Waiting for Flask app (ARM64) to start (max 60 seconds)..."
          for i in $(seq 1 120); do
            if curl -sf -I http://localhost:8001/api/last_task | grep -qE "HTTP/[12](.[01])? (2|3)[0-9]{2}"; then
              echo "Flask app (ARM64) is up and responsive!"
              exit 0
            fi
            echo "Waiting... ($i/120)"
            sleep 1
          done
          echo "Flask app (ARM64) did not start or respond with a successful status on /api/last_task within the expected time."
          docker logs flask-test-app-arm64
          exit 1

      - name: Run RQ Worker Container Health Check (AMD64)
        run: |
          echo "Starting temporary Redis container for RQ worker (AMD64)..."
          docker run -d --name redis-test-amd64 --platform linux/amd64 redis:latest

          echo "Waiting for Redis (AMD64) to start..."
          for i in $(seq 1 30); do
            if docker exec redis-test-amd64 redis-cli ping | grep -q PONG; then
              echo "Redis (AMD64) is ready."
              break
            fi
            echo "Waiting for Redis (AMD64)... ($i/30)"
            sleep 1
            if [ $i -eq 30 ]; then
              echo "Redis (AMD64) did not become ready in time."
              docker logs redis-test-amd64
              exit 1
            fi
          done

          echo "Starting temporary PostgreSQL container for RQ worker test (AMD64)..."
          docker run -d --name postgres-rq-test-amd64 --platform linux/amd64 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            postgres:latest # Changed to postgres:latest for better compatibility

          echo "Waiting for PostgreSQL (RQ worker test AMD64) to start..."
          for i in $(seq 1 30); do
            if docker exec postgres-rq-test-amd64 pg_isready -U testuser -d testdb -q; then
              echo "PostgreSQL (RQ worker test AMD64) is ready."
              break
            fi
            echo "Waiting for PostgreSQL (RQ worker test AMD64)... ($i/30)"
            sleep 2
            if [ $i -eq 30 ]; then
              echo "PostgreSQL (RQ worker test AMD64) did not become ready in time."
              docker logs postgres-rq-test-amd64
              exit 1
            fi
          done

          echo "Starting RQ worker container for health check (AMD64)..."
          docker run -d --name rq-test-worker-amd64 --platform linux/amd64 \
            --link redis-test-amd64:redis --link postgres-rq-test-amd64:postgres \
            -e SERVICE_TYPE=worker \
            -e REDIS_URL=redis://redis:6379/0 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            -e POSTGRES_HOST=postgres \
            -e POSTGRES_PORT=5432 \
            ${{ steps.docker_tags.outputs.test_tag }}

          echo "Waiting for RQ worker (AMD64) to start (max 90 seconds)..."
          for i in $(seq 1 30); do
            if docker ps -f name=rq-test-worker-amd64 --format '{{.Status}}' | grep -q 'Up'; then
              sleep 2
              if docker logs rq-test-worker-amd64 2>&1 | grep -E "Listening on|RQ Worker [^ ]+ started"; then
                  echo "RQ worker container (AMD64) is running and listening."
                  exit 0
              fi
            fi
            echo "Waiting... ($i/30)"
            sleep 3
          done
          echo "RQ worker container (AMD64) did not start or become ready within the expected time."
          docker logs rq-test-worker-amd64
          exit 1

      - name: Run RQ Worker Container Health Check (ARM64)
        run: |
          echo "Starting temporary Redis container for RQ worker (ARM64)..."
          docker run -d --name redis-test-arm64 --platform linux/arm64 redis:latest

          echo "Waiting for Redis (ARM64) to start..."
          for i in $(seq 1 30); do
            if docker exec redis-test-arm64 redis-cli ping | grep -q PONG; then
              echo "Redis (ARM64) is ready."
              break
            fi
            echo "Waiting for Redis (ARM64)... ($i/30)"
            sleep 1
            if [ $i -eq 30 ]; then
              echo "Redis (ARM64) did not become ready in time."
              docker logs redis-test-arm64
              exit 1
            fi
          done

          echo "Starting temporary PostgreSQL container for RQ worker test (ARM64)..."
          docker run -d --name postgres-rq-test-arm64 --platform linux/arm64 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            postgres:latest # Changed to postgres:latest for better compatibility

          echo "Waiting for PostgreSQL (RQ worker test ARM64) to start..."
          for i in $(seq 1 30); do
            if docker exec postgres-rq-test-arm64 pg_isready -U testuser -d testdb -q; then
              echo "PostgreSQL (RQ worker test ARM64) is ready."
              break
            fi
            echo "Waiting for PostgreSQL (RQ worker test ARM64)... ($i/30)"
            sleep 2
            if [ $i -eq 30 ]; then
              echo "PostgreSQL (RQ worker test ARM64) did not become ready in time."
              docker logs postgres-rq-test-arm64
              exit 1
            fi
          done

          echo "Starting RQ worker container for health check (ARM64)..."
          docker run -d --name rq-test-worker-arm64 --platform linux/arm64 \
            --link redis-test-arm64:redis --link postgres-rq-test-arm64:postgres \
            -e SERVICE_TYPE=worker \
            -e REDIS_URL=redis://redis:6379/0 \
            -e POSTGRES_USER=testuser \
            -e POSTGRES_PASSWORD=testpass \
            -e POSTGRES_DB=testdb \
            -e POSTGRES_HOST=postgres \
            -e POSTGRES_PORT=5432 \
            ${{ steps.docker_tags.outputs.test_tag }}

          echo "Waiting for RQ worker (ARM64) to start (max 90 seconds)..."
          for i in $(seq 1 30); do
            if docker ps -f name=rq-test-worker-arm64 --format '{{.Status}}' | grep -q 'Up'; then
              sleep 2
              if docker logs rq-test-worker-arm64 2>&1 | grep -E "Listening on|RQ Worker [^ ]+ started"; then
                  echo "RQ worker container (ARM64) is running and listening."
                  exit 0
              fi
            fi
            echo "Waiting... ($i/30)"
            sleep 3
          done
          echo "RQ worker container (ARM64) did not start or become ready within the expected time."
          docker logs rq-test-worker-arm64
          exit 1

      - name: Clean up Docker containers and temporary image
        if: always() # Run this step even if previous steps fail
        run: |
          echo "Cleaning up temporary Docker containers and image..."
          # Clean up Flask test containers
          docker rm -f flask-test-app-amd64 || true
          docker rm -f postgres-flask-test-amd64 || true
          docker rm -f flask-test-app-arm64 || true
          docker rm -f postgres-flask-test-arm64 || true
          # Clean up RQ worker test containers
          docker rm -f rq-test-worker-amd64 || true
          docker rm -f redis-test-amd64 || true
          docker rm -f postgres-rq-test-amd64 || true
          docker rm -f rq-test-worker-arm64 || true
          docker rm -f redis-test-arm64 || true
          docker rm -f postgres-rq-test-arm64 || true
          # Note: Removing the temporary multi-arch image from the local Docker daemon
          # will only remove the manifest list. Individual images might remain until
          # a `docker system prune` or similar is run. For GHCR, they will be there
          # until GHCR's cleanup policy or manual deletion.
          docker rmi ${{ steps.docker_tags.outputs.test_tag }} || true

      - name: Build and Push AudioMuse AI Image (Final Push)
        # This step only runs if all previous test steps passed
        if: success() # Only run this step if all previous steps in the job were successful
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64 # Build for both Intel and ARM architectures
          push: true
          tags: ${{ steps.docker_tags.outputs.docker_tags }}
