name: Build, Test, and Push AudioMuse AI Docker Image

on:
  push:
    branches:
      - main      # Trigger for 'latest'
      - devel     # Trigger for 'devel'
    tags:
      - 'v*.*.*'  # Trigger for version tags like v1.0.0

jobs:
  build-and-test:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write

    # Define services that will run alongside the job steps
    # These services will be accessible via 'localhost' at their mapped ports
    # when using --network host in docker run commands within steps.
    services:
      postgres:
        image: postgres:13 # Use an appropriate PostgreSQL version
        env:
          POSTGRES_USER: user # Match your config.py or test config
          POSTGRES_PASSWORD: password # Match your config.py or test config
          POSTGRES_DB: audiomuse_db_test # Use a test-specific DB name
        ports:
          - 5432:5432 # Map port 5432 of the service container to port 5432 on the host (runner)
        options: >- # Health check for PostgreSQL to wait until it's ready
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:6.2.6-alpine # Using a specific stable version
        ports:
          - 6379:6379 # Map port 6379 of the service container to port 6379 on the host (runner)
        options: >- # Health check for Redis
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Determine Docker image tags
        id: docker_tags
        run: |
          REPO_NAME_LOWER=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          ALL_TAGS=""

          if [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
            MAIN_TAG="ghcr.io/$REPO_NAME_LOWER:latest"
            ALL_TAGS="$MAIN_TAG"
            echo "Building latest tag: $MAIN_TAG"

          elif [[ "${GITHUB_REF}" == "refs/heads/devel" ]]; then
            DEV_TAG="ghcr.io/$REPO_NAME_LOWER:devel"
            ALL_TAGS="$DEV_TAG"
            echo "Building devel tag: $DEV_TAG"

          elif [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            VERSION_TAG=$(echo "${GITHUB_REF}" | sed -e 's|refs/tags/v||g')
            VERSIONED_TAG="ghcr.io/$REPO_NAME_LOWER:${VERSION_TAG}"
            ALL_TAGS="$VERSIONED_TAG"
            echo "Building versioned tag: $VERSIONED_TAG"
          fi

          # Export the tags for subsequent steps
          echo "docker_tags=$ALL_TAGS" >> "$GITHUB_OUTPUT"
          # Also export a simplified tag for internal testing purposes
          echo "test_tag=audiomuse-ai-temp:latest" >> "$GITHUB_OUTPUT"

      - name: Build Docker image (for testing)
        id: docker_build_test
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false # Do not push yet, just build
          tags: ${{ steps.docker_tags.outputs.test_tag }}
          load: true # Load image into Docker daemon for immediate use

      - name: Run Flask App Container Health Check
        run: |
          echo "Starting Flask app container for health check..."
          # Run the container in detached mode (-d) and map port 8000
          # Use --network host to allow access to services running on the host (runner)
          # DB_HOST and CELERY_BROKER_URL/CELERY_RESULT_BACKEND now point to localhost
          docker run -d --name flask-test-app -p 8000:8000 --network host \
            -e SERVICE_TYPE=flask \
            -e DB_HOST=localhost \
            -e DB_PORT=5432 \
            -e DB_NAME=audiomuse_db_test \
            -e DB_USER=user \
            -e DB_PASSWORD=password \
            -e CELERY_BROKER_URL=redis://localhost:6379/0 \
            -e CELERY_RESULT_BACKEND=redis://localhost:6379/0 \
            ${{ steps.docker_tags.outputs.test_tag }}

          echo "Waiting for Flask app to start (max 60 seconds)..."
          # Health check loop: Try to connect to the Flask app's /api/config endpoint
          # and check logs for database initialization messages.
          for i in $(seq 1 60); do
            # Check if the container is still running
            if ! docker ps -f name=flask-test-app --format '{{.Names}}' | grep -q flask-test-app; then
              echo "Flask app container unexpectedly stopped."
              docker logs flask-test-app # Print logs for debugging
              exit 1
            fi
            
            # Check if the app is responsive via its /api/config endpoint
            if curl -fsS http://localhost:8000/api/config > /dev/null; then
              echo "Flask app is up and responsive (checked /api/config)!"
              # Give it a few more seconds for DB initialization logs to appear
              sleep 5 
              if docker logs flask-test-app 2>&1 | grep -E "Table 'task_status' ensured to exist.|Table 'task_status' already exists"; then
                 echo "DB initialization messages found in Flask app logs. Flask app check passed."
                 exit 0
              else
                 echo "DB initialization messages NOT found yet. This might be okay if /api/config works."
                 # If /api/config works, we'll consider it a pass for now, but log the missing DB init message.
                 # If strict DB init log check is critical, uncomment the 'exit 1' below.
                 # exit 1 
                 exit 0 # Proceed if app is responsive, even if specific DB init log isn't seen immediately
              fi
            fi
            echo "Waiting... ($i/60)"
            sleep 1
          done
          echo "Flask app did not start, respond, or confirm DB initialization within the expected time."
          docker logs flask-test-app # Print logs for debugging
          exit 1 # Fail the job if app doesn't start

      - name: Run Celery Worker Container Health Check
        run: |
          echo "Starting Celery worker container for health check..."
          # Run the celery worker container in detached mode
          # Use --network host to allow access to services running on the host (runner)
          docker run -d --name celery-test-worker --network host \
            -e SERVICE_TYPE=celery \
            -e DB_HOST=localhost \
            -e DB_PORT=5432 \
            -e DB_NAME=audiomuse_db_test \
            -e DB_USER=user \
            -e DB_PASSWORD=password \
            -e CELERY_BROKER_URL=redis://localhost:6379/0 \
            -e CELERY_RESULT_BACKEND=redis://localhost:6379/0 \
            ${{ steps.docker_tags.outputs.test_tag }}

          echo "Waiting for Celery worker to start (max 90 seconds)..."
          # Check if the Celery worker container is running and if its logs indicate it's "ready"
          for i in $(seq 1 30); do
            if docker ps -f name=celery-test-worker --format '{{.Status}}' | grep -q 'Up'; then
              # Look for the "ready." log message which indicates full startup
              if docker logs celery-test-worker 2>&1 | grep -q "ready."; then
                  echo "Celery worker container is running and ready."
                  exit 0
              fi
            else
              echo "Celery worker container unexpectedly stopped."
              docker logs celery-test-worker # Print logs for debugging
              exit 1
            fi
            echo "Waiting for Celery worker to be ready... ($i/30)"
            sleep 3
          done
          echo "Celery worker container did not start or become ready within the expected time."
          docker logs celery-test-worker # Print logs for debugging
          exit 1 # Fail the job

      - name: Clean up Docker containers and temporary image
        if: always() # Run this step even if previous steps fail
        run: |
          echo "Cleaning up temporary Docker containers and image..."
          docker rm -f flask-test-app || true # || true prevents error if container didn't start or was already removed
          docker rm -f celery-test-worker || true
          # Redis and Postgres are managed by the 'services' block and cleaned up automatically by GitHub Actions.
          docker rmi ${{ steps.docker_tags.outputs.test_tag }} || true # Remove the temporary image

      - name: Build and Push AudioMuse AI Image (Final Push)
        # This step only runs if all previous test steps passed
        if: success() # Only run if previous steps (including health checks) succeeded
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: true
          tags: ${{ steps.docker_tags.outputs.docker_tags }}
