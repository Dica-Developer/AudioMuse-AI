# audiomuse-ai-deployment.yaml

---
apiVersion: v1
kind: Namespace
metadata:
  name: playlist
---
apiVersion: v1
kind: Secret
metadata:
  name: jellyfin-credentials
  namespace: playlist
type: Opaque
stringData:
  user_id: "0e45c44b3e2e4da7a2be11a72a1c8575" # Your Jellyfin User ID
  api_token: "e0b8c325bc1b426c81922b90c0aa2ff1" # Your Jellyfin API Token
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: audiomuse-ai-config
  namespace: playlist
data:
  JELLYFIN_URL: "http://jellyfin.192.168.3.131.nip.io:8087"
  CELERY_BROKER_URL: "redis://redis-service.playlist:6379/0"
  CELERY_RESULT_BACKEND: "redis://redis-service.playlist:6379/0"
  TEMP_DIR: "/app/temp_audio"
  # --- UPDATED: DBs now point to /workspace ---
  DB_PATH: "/workspace/db.sqlite"
  STATUS_DB_PATH: "/workspace/status_db.sqlite"
  NUM_RECENT_ALBUMS: "1300"
  CLUSTER_ALGORITHM: "kmeans"
  PCA_ENABLED: "False"
  NUM_CLUSTERS: "10"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: redis-master
  namespace: playlist
  labels:
    app: redis
    tier: backend
spec:
  replicas: 1
  selector:
    matchLabels:
      app: redis
      tier: backend
  template:
    metadata:
      labels:
        app: redis
        tier: backend
    spec:
      containers:
      - name: master
        image: redis:7-alpine # Lightweight Redis image
        resources:
          limits:
            cpu: 100m
            memory: 128Mi
          requests:
            cpu: 50m
            memory: 64Mi
        ports:
        - containerPort: 6379
---
apiVersion: v1
kind: Service
metadata:
  name: redis-service
  namespace: playlist
  labels:
    app: redis
    tier: backend
spec:
  ports:
  - port: 6379
    targetPort: 6379
  selector:
    app: redis
    tier: backend
  type: ClusterIP # Internal service only
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: audiomuse-ai-flask
  namespace: playlist
  labels:
    app: audiomuse-ai
    component: flask
spec:
  replicas: 1
  selector:
    matchLabels:
      app: audiomuse-ai
      component: flask
  template:
    metadata:
      labels:
        app: audiomuse-ai
        component: flask
    spec:
      nodeSelector: # Keep your node selector if needed
        kubernetes.io/hostname: ubuntu3
      securityContext:
        runAsUser: 0 # Or a non-root user if your image supports it
        runAsGroup: 0
        fsGroup: 0
      containers:
      - name: flask-app
        image: ghcr.io/neptunehub/audiomuse-ai:latest # Your image from GHCR
        imagePullPolicy: Always
        ports:
        - containerPort: 8000 # Flask app listens on 8000
        env:
        - name: SERVICE_TYPE
          value: "flask" # Tells the container to run the Flask app
        # --- Load Jellyfin Credentials from Secret ---
        - name: JELLYFIN_USER_ID
          valueFrom:
            secretKeyRef:
              name: jellyfin-credentials
              key: user_id
        - name: JELLYFIN_TOKEN
          valueFrom:
            secretKeyRef:
              name: jellyfin-credentials
              key: api_token
        # --- Load all other environment variables from the ConfigMap ---
        envFrom:
        - configMapRef:
            name: audiomuse-ai-config
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
        volumeMounts:
        # --- `temp_audio` uses emptyDir, but needs to be created if not mounted as volume
        - name: temp-audio-empty-dir
          mountPath: /app/temp_audio
        # --- `/workspace` now handles database storage ---
        - name: workspace-hostpath
          mountPath: /workspace # Mounts the host path for legacy/external access including DBs
      volumes:
      - name: temp-audio-empty-dir
        emptyDir: {} # Temporary storage for downloaded audio
      - name: workspace-hostpath
        hostPath:
          path: /mnt/workspace # Your host path - Databases will live here
          type: DirectoryOrCreate
---
apiVersion: v1
kind: Service
metadata:
  name: audiomuse-ai-flask-service
  namespace: playlist
  labels:
    app: audiomuse-ai
    component: flask
spec:
  selector:
    app: audiomuse-ai
    component: flask
  ports:
  - protocol: TCP
    port: 8000 # Service port (what you connect to)
    targetPort: 8000 # Container port (what the app listens on)
  type: LoadBalancer # Or NodePort/ClusterIP depending on your K3S setup
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: audiomuse-ai-celery
  namespace: playlist
  labels:
    app: audiomuse-ai
    component: celery
spec:
  replicas: 1 # Scale as needed for parallel processing
  selector:
    matchLabels:
      app: audiomuse-ai
      component: celery
  template:
    metadata:
      labels:
        app: audiomuse-ai
        component: celery
    spec:
      nodeSelector: # Keep your node selector if needed
        kubernetes.io/hostname: ubuntu3
      securityContext:
        runAsUser: 0
        runAsGroup: 0
        fsGroup: 0
      containers:
      - name: celery-worker
        image: ghcr.io/neptunehub/audiomuse-ai:latest # Your image from GHCR
        imagePullPolicy: Always
        env:
        - name: SERVICE_TYPE
          value: "celery" # Tells the container to run the Celery worker
        - name: C_FORCE_ROOT
          value: "true"
        # --- Load Jellyfin Credentials from Secret ---
        - name: JELLYFIN_USER_ID
          valueFrom:
            secretKeyRef:
              name: jellyfin-credentials
              key: user_id
        - name: JELLYFIN_TOKEN
          valueFrom:
            secretKeyRef:
              name: jellyfin-credentials
              key: api_token
        # --- Load all other environment variables from the ConfigMap ---
        envFrom:
        - configMapRef:
            name: audiomuse-ai-config
        securityContext:
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
        volumeMounts:
        # --- `temp_audio` uses emptyDir, but needs to be created if not mounted as volume
        - name: temp-audio-empty-dir
          mountPath: /app/temp_audio
        # --- `/workspace` now handles database storage ---
        - name: workspace-hostpath
          mountPath: /workspace # Mounts the host path for legacy/external access including DBs
      volumes:
      - name: temp-audio-empty-dir
        emptyDir: {}
      - name: workspace-hostpath
        hostPath:
          path: "/mnt/workspace" # Your host path - Databases will live here
          type: DirectoryOrCreate
